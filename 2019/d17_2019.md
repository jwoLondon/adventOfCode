---
follows: data/d17_2019.md

id: "litvis"
---

@import "../css/aoc.less"

# Day 17 (2019): Set and Forget

'Part One' and 'Part Two' puzzle descriptions and puzzle input from [Advent of Code](https://adventofcode.com/2019/day/17)

## Part 1

The scaffold grid data are generated by the intcode computer. We can convert to a Grid for easy direct manipulation.

```elm {l}
scaffolds : AOC.Grid Char
scaffolds =
    puzzleInput
        |> initComputer []
        |> runProg
        |> .outputStore
        |> List.map Char.fromCode
        |> String.fromList
        |> String.lines
        |> List.map String.toList
        |> AOC.gFromLists
```

It is useful to be able to display the map of scaffolds along which the robot can move. For improved display, we can convert characters to unicode (non-ASCII !) symbols.

```elm {l}
display : AOC.Grid Char -> List String
display =
    AOC.gToLists
        >> List.map String.fromList
        >> List.map
            (String.replace "." "░\u{2004}"
                >> String.replace "#" "█\u{2004}"
                >> String.replace ">" "⇨"
                >> String.replace "^" "⇧"
                >> String.replace "<" "⇦"
                >> String.replace "v" "⇩"
                >> AOC.flip (++) "\n"
            )
```

{(fixed|} ^^^elm {m=(display scaffolds)}^^^ {|fixed)}

Visual inspection confirms that all intersections are isolated from each other so we can detect them by looking for 3x3 windows in the grid with a pattern of:

{(fixed|}
░ █ ░
█ █ █
░ █ ░
{|fixed)}

We can detect this by scanning the grid looking for N,S,E and W neighbours:

```elm {l}
intersections : AOC.Grid Char -> List ( Int, Int )
intersections grid =
    let
        isIntersection ( row, col ) cell =
            case cell of
                '#' ->
                    if
                        AOC.gGet ( row - 1, col ) grid
                            == Just '#'
                            && AOC.gGet ( row + 1, col ) grid
                            == Just '#'
                            && AOC.gGet ( row, col - 1 ) grid
                            == Just '#'
                            && AOC.gGet ( row, col + 1 ) grid
                            == Just '#'
                    then
                        Just ( row, col )

                    else
                        Nothing

                _ ->
                    Nothing
    in
    grid
        |> AOC.gMapWithLocation isIntersection
        |> AOC.gToList
        |> List.filterMap identity
```

From the list of intersections we can generate sum of alignments:

```elm {l r}
part1 : Int
part1 =
    scaffolds
        |> intersections
        |> List.map (\( x, y ) -> x * y)
        |> List.sum
```

---

## Part 2

This is a more challenging task to automate. Visual inspection of the scaffold map suggests a single shortest route that starts from initial position of the droid and ends at the only other terminus.

This route is generated with the instructions:

[L,12, R,4,R,4, L,6, L,12, R,4, R,4, R,12, L,12, R,4, R,4, L,6, L,10, L,6, R,4, L,12, R,4, R,4, L,6, L,12, R,4, R,4, R,12, L,10, L,6, R,4, L,12, R,4, R,4, R,12, L,10, L,6, R,4, L,12, R,4, R,4, L,6]

Given the twin constraints of only 3 'functions' and each function a maximum of 20 characters, we can apply a greedy function generation process, here done manually given the simple size of the problem:

- _While instructions remain in list:_

  - _Proceed from start of list adding them to a new function until no more can be added within the 20 character limit._

  - _Substitute any instructions in the list with the new function._

This leads to the following generation of functions:

- **A = [L, 12, R, 4, R, 4, L, 6]**

  A, [L, 12, R, 4 R, 4R, 12], A, [L, 10, L, 6, R, 4], A, [L, 12, R, 4, R, 4, R, 12, L, 10, L, 6, R, 4, L, 12, R, 4, R, 4, R, 12, L, 10, L, 6, R, 4], A

- **B = [L, 12, R, 4 R, 4R, 12]**

  A, B, A, [L, 10, L, 6, R, 4], A, B, [L, 10, L, 6, R, 4], B, [L, 10, L, 6, R, 4], A

- **C = [L, 10, L, 6, R, 4]**

  A, B, A, C, A, B, C, B, C, A

Now we have the functions and their sequence, we just need to convert to ascii before finding the output of the intcode with this input.

```elm {l}
toAscii : String -> List Int
toAscii =
    String.toList
        >> List.map Char.toCode
        >> List.reverse
        >> (::) 10
        >> List.reverse
```

```elm {l r}
part2 : Int
part2 =
    let
        instrs =
            [ "A,B,A,C,A,B,C,B,C,A"
            , "L,12,R,4,R,4,L,6"
            , "L,12,R,4,R,4,R,12"
            , "L,10,L,6,R,4"
            , "N"
            ]
    in
    puzzleInput
        |> initComputer (List.concatMap toAscii instrs)
        |> poke 0 2
        |> runProg
        |> .out
```

---

## Reflection

The first of this year's puzzle where a solution via inspection is possible given the constraints of the scaffold path generated by the input. There is no guarantee that the greedy function assignment used in part two would work for all inputs, but presumably it is likely all puzzle inputs generate such a sequence amenable to a process.

It would be possible to automate part two by calculating the shortest path and then applying the greedy function assignment, but I am not sure the effort is worth it given the specifics of the puzzle input and the small size of the problem.
