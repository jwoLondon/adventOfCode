---
follows: data/d24_2019.md

id: "litvis"
---

@import "../css/aoc.less"

# Day 24 (2019): Planet of Discord

'Part One' and 'Part Two' puzzle descriptions and puzzle input from [Advent of Code](https://adventofcode.com/2019/day/24):

{( part1|}

You land on Eris, your last stop before reaching Santa. As soon as you do, your sensors start picking up strange life forms moving around: Eris is infested with bugs! With an over 24-hour roundtrip for messages between you and Earth, you'll have to deal with this problem on your own.

Eris isn't a very large place; a scan of the entire area fits into a 5x5 grid (your puzzle input). The scan shows **bugs** (#) and **empty spaces** (.).

Each **minute**, The bugs live and die based on the number of bugs in the **four adjacent tiles**:

- A bug dies (becoming an empty space) unless there is exactly one bug adjacent to it.
- An empty space becomes infested with a bug if exactly one or two bugs are adjacent to it.

Otherwise, a bug or empty space remains the same. (Tiles on the edges of the grid have fewer than four adjacent tiles; the missing tiles count as empty space.) This process happens in every location **simultaneously**; that is, within the same minute, the number of adjacent bugs is counted for every tile first, and then the tiles are updated.

Here are the first few minutes of an example scenario:

Initial state:

```txt
....#
#..#.
#..##
..#..
#....
```

After 1 minute:

```txt
#..#.
####.
###.#
##.##
.##..
```

After 2 minutes:

```txt
#####
....#
....#
...#.
#.###
```

After 3 minutes:

```txt
#....
####.
...##
#.##.
.##.#
```

After 4 minutes:

```txt
####.
....#
##..#
.....
##...
```

To understand the nature of the bugs, watch for the first time a layout of bugs and empty spaces **matches any previous layout**. In the example above, the first layout to appear twice is:

```txt
.....
.....
.....
#....
.#...
```

To calculate the **biodiversity rating** for this layout, consider each tile left-to-right in the top row, then left-to-right in the second row, and so on. Each of these tiles is worth biodiversity points equal to **increasing powers of two**: 1, 2, 4, 8, 16, 32, and so on. Add up the biodiversity points for tiles with bugs; in this example, the 16th tile (32768 points) and 22nd tile (2097152 points) have bugs, a total biodiversity rating of **2129920**.

**What is the biodiversity rating for the first layout that appears twice?**

{| part1 )}

## Parsing and Data Structure

We can represent the live cells as a set, avoiding the need to store a full grid.

```elm {l}
type alias Cell =
    ( Int, Int )


type alias Grid =
    Set Cell
```

Parsing is simple as we just need to identify the `#` characters in the ordered set of input strings.

```elm {l}
parse : List String -> Grid
parse lines =
    let
        rows =
            List.indexedMap (\row cs -> ( row, cs )) lines

        cols ( row, cs ) =
            List.indexedMap (\col c -> ( ( col, row ), c )) (String.toList cs)
    in
    List.concatMap cols rows
        |> List.filter (\( _, c ) -> c == '#')
        |> List.map Tuple.first
        |> Set.fromList
```

and we can confirm the status of any grid by displaying it:

```elm {l}
showCell : Grid -> Cell -> Char
showCell liveCells p =
    if Set.member p liveCells then
        'ðŸž'

    else
        'ðŸŒ±'
```

```elm {l}
display : (Cell -> Char) -> String
display toChr =
    let
        addRow y =
            (++) (List.map (\x -> toChr ( x, y )) (List.range 0 4) ++ [ '\n' ])
    in
    List.foldr addRow [] (List.range 0 4) |> String.fromList
```

{(fixed|}^^^elm {m=(display (showCell (parse test1Input)))}^^^{|fixed)}

## Approach

This would appear to be a standard cellular automata / Game of Life implementation with a cliff-edge beyond (0,0) and (4,4) and the additional need to detect cycles (e.g. like [day 18, 2015](../2015/d18_2015.md)).

The only cells that can change their bug/space status from one generation to the next will be those at current bug locations or their immediate neighbours. Anything outside of those location would be too far away from any bug to change so do not need to be considered.

We therefore need to identify any cell's immediate neighbours:

```elm {l}
neighbours : Cell -> Grid
neighbours ( x0, y0 ) =
    [ ( x0 - 1, y0 ), ( x0 + 1, y0 ), ( x0, y0 - 1 ), ( x0, y0 + 1 ) ]
        |> List.filter (\( x, y ) -> x >= 0 && y >= 0 && x < 5 && y < 5)
        |> Set.fromList
```

in order to count the number of neighbouring bugs:

```elm {l}
numNeighbouringBugs : Grid -> Cell -> Int
numNeighbouringBugs bugs cell =
    Set.intersect bugs (neighbours cell) |> Set.size
```

The basic life death rules can be encoded:

```elm {l}
rule : Bool -> Int -> Bool
rule isAlive n =
    n == 1 || (not <| isAlive) && n == 2
```

which allows us to decide whether a cell will be alive in the next generation:

```elm {l}
live : Grid -> Cell -> Bool
live bugs cell =
    rule (Set.member cell bugs) (numNeighbouringBugs bugs cell)
```

which we can apply to all bug cells and their immediate neighbours:

```elm {l}
generation : Grid -> Grid
generation bugs =
    bugs
        |> Set.toList
        |> List.concatMap (Set.toList << neighbours)
        |> Set.fromList
        |> Set.filter (live bugs)
```

We can use `sequenceCycle` from [Aoc.elm](../src/Aoc.md) to detect a repeated sequence.

```elm {l}
firstRepeat : Grid -> Grid
firstRepeat initCells =
    case AOC.sequenceCycle 0 initCells generation of
        Just ( _, cyclePos ) ->
            AOC.iterate cyclePos initCells generation

        Nothing ->
            initCells |> Debug.log "No repeats found"
```

Finally, once we have a set of bugs after some generations we need to be able to calculate its biodiversity rating:

```elm {l}
biodiversity : Grid -> Int
biodiversity =
    Set.map (\( x, y ) -> 2 ^ (y * 5 + x)) >> Set.foldl (+) 0
```

```elm {l r}
part1 : Int
part1 =
    puzzleInput
        |> parse
        |> firstRepeat
        |> biodiversity
```

{( part2 |}

After careful analysis, one thing is certain: **you have no idea where all these bugs are coming from**.

Then, you remember: Eris is an old Plutonian settlement! Clearly, the bugs are coming from recursively-folded space.

This 5x5 grid is **only one** level in an **infinite** number of recursion levels. The tile in the middle of the grid is actually another 5x5 grid, the grid in your scan is contained as the middle tile of a larger 5x5 grid, and so on. Two levels of grids look like this:

```txt
     |     |         |     |
     |     |         |     |
     |     |         |     |
-----+-----+---------+-----+-----
     |     |         |     |
     |     |         |     |
     |     |         |     |
-----+-----+---------+-----+-----
     |     | | | | | |     |
     |     |-+-+-+-+-|     |
     |     | | | | | |     |
     |     |-+-+-+-+-|     |
     |     | | |?| | |     |
     |     |-+-+-+-+-|     |
     |     | | | | | |     |
     |     |-+-+-+-+-|     |
     |     | | | | | |     |
-----+-----+---------+-----+-----
     |     |         |     |
     |     |         |     |
     |     |         |     |
-----+-----+---------+-----+-----
     |     |         |     |
     |     |         |     |
     |     |         |     |
```

(To save space, some of the tiles are not drawn to scale.) Remember, this is only a small part of the infinitely recursive grid; there is a 5x5 grid that contains this diagram, and a 5x5 grid that contains that one, and so on. Also, the ? in the diagram contains another 5x5 grid, which itself contains another 5x5 grid, and so on.

The scan you took (your puzzle input) shows where the bugs are **on a single level** of this structure. The middle tile of your scan is empty to accommodate the recursive grids within it. Initially, no other levels contain bugs.

Tiles still count as **adjacent** if they are directly **up, down, left, or right** of a given tile. Some tiles have adjacent tiles at a recursion level above or below its own level. For example:

```txt
     |     |         |     |
  1  |  2  |    3    |  4  |  5
     |     |         |     |
-----+-----+---------+-----+-----
     |     |         |     |
  6  |  7  |    8    |  9  |  10
     |     |         |     |
-----+-----+---------+-----+-----
     |     |A|B|C|D|E|     |
     |     |-+-+-+-+-|     |
     |     |F|G|H|I|J|     |
     |     |-+-+-+-+-|     |
 11  | 12  |K|L|?|N|O|  14 |  15
     |     |-+-+-+-+-|     |
     |     |P|Q|R|S|T|     |
     |     |-+-+-+-+-|     |
     |     |U|V|W|X|Y|     |
-----+-----+---------+-----+-----
     |     |         |     |
 16  | 17  |    18   |  19 |  20
     |     |         |     |
-----+-----+---------+-----+-----
     |     |         |     |
 21  | 22  |    23   |  24 |  25
     |     |         |     |
```

Tile 19 has four adjacent tiles: 14, 18, 20, and 24.
Tile G has four adjacent tiles: B, F, H, and L.
Tile D has four adjacent tiles: 8, C, E, and I.
Tile E has four adjacent tiles: 8, D, 14, and J.
Tile 14 has **eight** adjacent tiles: 9, E, J, O, T, Y, 15, and 19.
Tile N has **eight** adjacent tiles: I, O, S, and five tiles within the sub-grid marked ?.
The rules about bugs living and dying are the same as before.

For example, consider the same initial state as above:

```txt
....#
#..#.
#.?##
..#..
#....
```

The center tile is drawn as ? to indicate the next recursive grid. Call this level 0; the grid within this one is level 1, and the grid that contains this one is level -1. Then, after **ten** minutes, the grid at each level would look like this:

Depth -5:

```txt
..#..
.#.#.
..?.#
.#.#.
..#..
```

Depth -4:

```txt
...#.
...##
..?..
...##
...#.
```

Depth -3:

```txt
#.#..
.#...
..?..
.#...
#.#..
```

Depth -2:

```txt
.#.##
....#
..?.#
...##
.###.
```

Depth -1:

```txt
#..##
...##
..?..
...#.
.####
```

Depth 0:

```txt
.#...
.#.##
.#?..
.....
.....
```

Depth 1:

```txt
.##..
#..##
..?.#
##.##
#####
```

Depth 2:

```txt
###..
##.#.
#.?..
.#.##
#.#..
```

Depth 3:

```txt
..###
.....
#.?..
#....
#...#
```

Depth 4:

```txt
.###.
#..#.
#.?..
##.#.
.....
```

Depth 5:

```txt
####.
#..#.
#.?#.
####.
.....
```

In this example, after 10 minutes, a total of **99** bugs are present.

Starting with your scan, **how many bugs are present after 200 minutes?**

{| part2 )}

## Approach Part Two

To account for the recursive nature of the tiles we can add an extra dimension to each cell recording its depth.

```elm {l}
type alias Cell2 =
    ( Int, Int, Int )


type alias Grid2 =
    Set Cell2
```

The depth and number of adjacent cells will change for central or outer neighbours:

```elm {l}
neighbours2 : Cell2 -> Grid2
neighbours2 ( x0, y0, d ) =
    let
        adjacentCells ( fromX, fromY ) ( toX, toY ) =
            -- Outer neighbours
            if toX < 0 then
                [ ( 1, 2, d - 1 ) ]

            else if toX > 4 then
                [ ( 3, 2, d - 1 ) ]

            else if toY < 0 then
                [ ( 2, 1, d - 1 ) ]

            else if toY > 4 then
                [ ( 2, 3, d - 1 ) ]

            else if toX == 2 && toY == 2 then
                -- Inner neighbours
                if fromX == 1 then
                    List.map (\y -> ( 0, y, d + 1 )) (List.range 0 4)

                else if fromX == 3 then
                    List.map (\y -> ( 4, y, d + 1 )) (List.range 0 4)

                else if fromY == 1 then
                    List.map (\x -> ( x, 0, d + 1 )) (List.range 0 4)

                else
                    List.map (\x -> ( x, 4, d + 1 )) (List.range 0 4)

            else
                -- Internal neighbours
                [ ( toX, toY, d ) ]
    in
    [ ( x0 - 1, y0 ), ( x0 + 1, y0 ), ( x0, y0 - 1 ), ( x0, y0 + 1 ) ]
        |> List.concatMap (adjacentCells ( x0, y0 ))
        |> Set.fromList
```

To calculate the next generation we can proceed as with part one but with the new adjacency rules:

```elm {l}
numNeighbouringBugs2 : Grid2 -> Cell2 -> Int
numNeighbouringBugs2 bugs cell =
    Set.intersect bugs (neighbours2 cell) |> Set.size
```

```elm {l}
live2 : Grid2 -> Cell2 -> Bool
live2 bugs cell =
    rule (Set.member cell bugs) (numNeighbouringBugs2 bugs cell)
```

```elm {l}
generation2 : Grid2 -> Grid2
generation2 bugs =
    bugs
        |> Set.toList
        |> List.concatMap (Set.toList << neighbours2)
        |> Set.fromList
        |> Set.filter (live2 bugs)
```

```elm {l r}
part2 : Int
part2 =
    let
        init =
            puzzleInput
                |> parse
                |> Set.map (\( x, y ) -> ( x, y, 0 ))
    in
    AOC.iterate 200 init generation2
        |> Set.size
```

---

## Reflection

Part one was a simple implementation of cellular automata with rooks-case adjacency so was easy to implement. The clamping of the neighbourhood to a 5x5 grid allowed cycles to be more easily generated leading to a quick computation of the cycle period.

My initial attempt at part two created a tree data structure for nested grids, but this not necessary as the tree was a single branch in each direction away from the initial grid. It was therefore much simplified by storing the grid depth as a third element in each cell's tuple representation.
