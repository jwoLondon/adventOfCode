---
follows: data/d23_2019.md

id: "litvis"
---

@import "../css/aoc.less"

# Day 23 (2019): Category Six

'Part One' and 'Part Two' puzzle descriptions and puzzle input from [Advent of Code](https://adventofcode.com/2019/day/23):

{( part1|}

The droids have finished repairing as much of the ship as they can. Their report indicates that this was a **Category 6 disaster** - not because it was that bad, but because it destroyed the stockpile of Category 6 network cables as well as most of the ship's network infrastructure.

You'll need to rebuild the network from scratch.

The computers on the network are standard Intcode computers that communicate by sending **packets** to each other. There are 50 of them in total, each running a copy of the same **Network Interface Controller** (NIC) software (your puzzle input). The computers have network addresses 0 through 49; when each computer boots up, it will request its network address via a single input instruction. Be sure to give each computer a unique network address.

Once a computer has received its network address, it will begin doing work and communicating over the network by sending and receiving packets. All packets contain **two values** named X and Y. Packets sent to a computer are queued by the recipient and read in the order they are received.

To **send** a packet to another computer, the NIC will use **three output instructions **that provide the **destination address** of the packet followed by its X and Y values. For example, three output instructions that provide the values 10, 20, 30 would send a packet with X=20 and Y=30 to the computer with address 10.

To **receive** a packet from another computer, the NIC will use an input **instruction**. If the incoming packet queue is **empty**, provide -1. Otherwise, provide the X value of the next packet; the computer will then use a second input instruction to receive the Y value for the same packet. Once both values of the packet are read in this way, the packet is removed from the queue.

Note that these input and output instructions never block. Specifically, output instructions do not wait for the sent packet to be received - the computer might send multiple packets before receiving any. Similarly, input instructions do not wait for a packet to arrive - if no packet is waiting, input instructions should receive -1.

Boot up all 50 computers and attach them to your network. **What is the Y value of the first packet sent to address 255?**

{| part1 )}

## Approach

Create a dictionary of 50 computers, each referenced by its network address (0-49) plus one extra computer at address 255 to accept input.

```elm {l}
type alias Network =
    Dict Int Computer


initComputers : Network
initComputers =
    List.foldl
        (\addr ->
            Dict.insert addr (puzzleInput |> initComputer [ addr ] |> runProg)
        )
        Dict.empty
        (List.range 0 49)
        |> Dict.insert 255 ([ 3, 3, 99 ] |> initComputer [])
```

We can represent packets as a dictionary where the key is the destination address of the packet and the value is a list of the x,y pairs contained within the packets due to be sent to that address.

```elm {l}
type alias Packets =
    Dict Int (List Int)
```

When a computer generates one ore more packets to send, we can add them to the packet queue due for the destination computer:

```elm {l}
extractPackets : Computer -> Packets -> Packets
extractPackets comp packets =
    let
        updatePackets ns pks =
            case ns of
                [ addr, x, y ] ->
                    case Dict.get addr pks of
                        Just xys ->
                            Dict.insert addr (xys ++ [ x, y ]) pks

                        Nothing ->
                            Dict.insert addr [ x, y ] pks

                _ ->
                    pks |> Debug.log "Expecting output to be in triplets"
    in
    List.foldl updatePackets packets (comp.outputStore |> groupsOf 3)
```

Every cycle we gather any new outputs from computers 0 to 49 and allocate them to the relevant computers in the network, including the possibility of the special computer at address 255.

```elm {l}
tick : Network -> Network
tick computers =
    let
        packets =
            List.foldl (addInput -1 >> runProg >> extractPackets)
                Dict.empty
                (Dict.values computers)

        allocatePackets ps network =
            Dict.foldl
                (\id xys cs ->
                    case Dict.get id cs of
                        Just comp ->
                            Dict.insert id (addInputs (List.reverse xys) comp) cs

                        Nothing ->
                            cs |> Debug.log "Unexpected id"
                )
                network
                ps
    in
    computers
        |> Dict.map (always clearOutput)
        |> allocatePackets packets
```

We can now just run the computer network for some cycles until we receive a packet for computer 255:

```elm {l r}
part1 : Int
part1 =
    let
        repeatUntil255 computers =
            case computers |> tick |> Dict.get 255 of
                Just comp ->
                    if (comp |> runProg |> .inputStore) == [] then
                        repeatUntil255 (computers |> tick)

                    else
                        comp |> runProg |> .inputStore |> List.head |> Maybe.withDefault -1

                Nothing ->
                    -1
    in
    repeatUntil255 initComputers
```

{( part2 |}

Packets sent to address 255 are handled by a device called a NAT (Not Always Transmitting). The NAT is responsible for managing power consumption of the network by blocking certain packets and watching for idle periods in the computers.

If a packet would be sent to address 255, the NAT receives it instead. The NAT remembers only the **last** packet it receives; that is, the data in each packet it receives overwrites the NAT's packet memory with the new packet's X and Y values.

The NAT also monitors all computers on the network. If all computers have **empty incoming packet queues** and are **continuously trying to receive packets** without sending packets, the network is considered **idle**.

Once the network is idle, the NAT sends **only the last packet it received** to address 0; this will cause the computers on the network to resume activity. In this way, the NAT can throttle power consumption of the network when the ship needs power in other areas.

Monitor packets released to the computer at address 0 by the NAT. **What is the first Y value delivered by the NAT to the computer at address 0 twice in a row?**

{| part2 )}

## Approach

We need to be able to detect when all computers in the network are idle:

```elm {l}
isIdle : Network -> Bool
isIdle network =
    network
        |> Dict.remove 255
        |> Dict.values
        |> List.map .inputStore
        |> List.concat
        |> List.length
        |> Debug.log ""
        |> (==) 0
```

The modified tick, which runs once per cycle, has to detect an idle network and send the last packet from the NAT (computer 255) to computer 0:

```elm {l}
tick2 : Network -> Network
tick2 computers =
    let
        packets =
            List.foldl (addInput -1 >> runProg >> extractPackets)
                Dict.empty
                (Dict.values computers)

        allocatePackets ps network =
            Dict.foldl
                (\id xys cs ->
                    case Dict.get id cs of
                        Just comp ->
                            Dict.insert id (addInputs (List.reverse xys) comp) cs

                        Nothing ->
                            cs |> Debug.log "Unexpected id"
                )
                network
                ps

        newNetwork =
            computers
                |> Dict.map (always clearOutput)
                |> allocatePackets packets
    in
    if isIdle computers then
        -- let
        --     _ =
        --         Debug.log "idle with NAT storing" (Dict.get 255 newNetwork)
        -- in
        newNetwork

    else
        newNetwork
```

```elm {l r}
part2 : Int
part2 =
    case iterate 9 initComputers tick2 |> Dict.get 0 of
        Just comp ->
            comp |> runProg |> .inputStore |> List.head |> Maybe.withDefault -1

        Nothing ->
            -1
```

### Reflection
