---
follows: data/d21_2019.md

id: "litvis"
---

@import "../css/aoc.less"

# Day 21 (2019): Springdroid Adventure

'Part One' and 'Part Two' puzzle descriptions and puzzle input from [Advent of Code](https://adventofcode.com/2019/day/21):

{( part1|}

You lift off from Pluto and start flying in the direction of Santa.

While experimenting further with the tractor beam, you accidentally pull an asteroid directly into your ship! It deals significant damage to your hull and causes your ship to begin tumbling violently.

You can send a droid out to investigate, but the tumbling is causing enough artificial gravity that one wrong step could send the droid through a hole in the hull and flying out into space.

The clear choice for this mission is a droid that can **jump** over the holes in the hull - a **springdroid**.

You can use an Intcode program (your puzzle input) running on an ASCII-capable computer to program the springdroid. However, springdroids don't run Intcode; instead, they run a simplified assembly language called **springscript**.

While a springdroid is certainly capable of navigating the artificial gravity and giant holes, it has one downside: it can only remember at most 15 springscript instructions.

The springdroid will move forward automatically, constantly thinking about **whether to jump**. The springscript program defines the logic for this decision.

Springscript programs only use Boolean values, not numbers or strings. Two registers are available: T, the **temporary value** register, and J, the jump register. If the jump register is true at the end of the springscript program, the springdroid will try to jump. Both of these registers start with the value **false**.

Springdroids have a sensor that can detect **whether there is ground** at various distances in the direction it is facing; these values are provided in **read-only registers**. Your springdroid can detect ground at four distances: one tile away (A), two tiles away (B), three tiles away (C), and four tiles away (D). If there is ground at the given distance, the register will be true; if there is a hole, the register will be false.

There are only **three instructions** available in springscript:

- AND X Y sets Y to **true** if both X and Y are **true**; otherwise, it sets Y to **false**.
- OR X Y sets Y to **true** if at least one of X or Y is **true**; otherwise, it sets Y to **false**.
- NOT X Y sets Y to **true** if X is **false**; otherwise, it sets Y to **false**.

In all three instructions, the second argument (Y) needs to be a **writable register** (either T or J). The first argument (X) can be **any register** (including A, B, C, or D).

For example, the one-instruction program NOT A J means "if the tile immediately in front of me is not ground, jump".

Or, here is a program that jumps if a three-tile-wide hole (with ground on the other side of the hole) is detected:

NOT A J
NOT B T
AND T J
NOT C T
AND T J
AND D J

The Intcode program expects ASCII inputs and outputs. It will begin by displaying a prompt; then, input the desired instructions one per line. End each line with a newline (ASCII code 10). **When you have finished entering your program**, provide the command WALK followed by a newline to instruct the springdroid to begin surveying the hull.

If the springdroid **falls into space**, an ASCII rendering of the last moments of its life will be produced. In these, @ is the springdroid, # is hull, and . is empty space. For example, suppose you program the springdroid like this:

NOT D J
WALK

This one-instruction program sets J to **true** if and only if there is no ground four tiles away. In other words, it attempts to jump into any hole it finds:

    .................
    .................
    @................
    #####.###########

    .................
    .................
    .@...............
    #####.###########

    .................
    ..@..............
    .................
    #####.###########

    ...@.............
    .................
    .................
    #####.###########

    .................
    ....@............
    .................
    #####.###########

    .................
    .................
    .....@...........
    #####.###########

    .................
    .................
    .................
    #####@###########

However, if the springdroid successfully makes it across, it will use an output instruction to indicate the **amount of damage to the hull** as a single giant integer outside the normal ASCII range.

Program the springdroid with logic that allows it to survey the hull without falling into space. **What amount of hull damage does it report?**

{| part1 )}

## Parsing

To generate input to the springdroid, we need to be able to generate ASCII springscript from readable instructions by converting each character in the instructions to its ASCII code and adding a 10 (ASCII newline) at the end of each instruction.

```elm {l}
springscript : List String -> List Int
springscript =
    List.map (String.toList >> List.map Char.toCode >> AOC.flip (++) [ 10 ])
        >> List.concat
```

To view output from the springdroid, we need to be able to perform an equivalent translation of ASCII output codes back into text. This will either be a map of the last part of the hull before the droid fell through a hole (ASCII characters), or a non-ASCII code reporting the damage:

```elm {l}
droidReport : List Int -> String
droidReport sdOut =
    case List.filter ((<=) 255) sdOut of
        damage :: [] ->
            "Scanned " ++ String.fromInt damage ++ " damage."

        _ ->
            sdOut
                |> List.map Char.fromCode
                |> String.fromList
                |> String.replace "#" "█"
```

## Approach

Setting off the droid is simply a matter of providing some springscript and viewing the output.

```elm {l}
activateDroid : List Int -> List Int
activateDroid instrs =
    puzzleInput
        |> initComputer instrs
        |> runProg
        |> .outputStore
```

The springscript to avoid holes: `¬A ∨ (¬C ∧ D)` (Jump if next step is a hole or hole in 3 steps and ground in 4).

We can rearrange so the logical predicates are applied in order with just a single register:

`¬A ∨ (¬C ∧ D) = ¬C ∧ D ∨ ¬A = ¬(¬D ∨ C ∧ A )`

```elm {l}
droidProg : List String
droidProg =
    [ "NOT D J"
    , "OR C J"
    , "AND A J"
    , "NOT J J"
    , "WALK"
    ]
```

{(fixed|}

```elm {m}
part1 : String
part1 =
    droidProg
        |> springscript
        |> activateDroid
        |> droidReport
```

{|fixed)}

{( part2 |}

There are many areas the springdroid can't reach. You flip through the manual and discover a way to **increase its sensor range**.

Instead of ending your springcode program with WALK, use RUN. Doing this will enable **extended sensor mode**, capable of sensing ground up to **nine tiles away**. This data is available in **five new read-only registers**:

- Register E indicates whether there is ground **five** tiles away.
- Register F indicates whether there is ground **six** tiles away.
- Register G indicates whether there is ground **seven** tiles away.
- Register H indicates whether there is ground **eight** tiles away.
- Register I indicates whether there is ground **nine** tiles away.

All other functions remain the same.

Successfully survey the rest of the hull by ending your program with RUN. **What amount of hull damage does the springdroid now report?**

{| part2 )}

## Springcode

To avoid the longer sequence of holes:

- If there are holes within 3 steps and hull 4 steps in front, then jump:
  `¬A ∨ ¬B ∨ ¬C ∧ D`
  - but only if there is hull 5 or 8 steps in front
    `∧ (E ∨ H)`

We can reduce (but not remove) the reliance the temporary register by grouping the nots (negating a group just involves `NOT J J` after the group):

`¬(A ∧ B ∧ C) ∧ D ∧ (E ∨ H)`

```elm {l}
droidProg2 : List String
droidProg2 =
    [ "OR A J"
    , "AND B J"
    , "AND C J"
    , "NOT J J"
    , "AND D J"
    , "OR E T"
    , "OR H T"
    , "AND T J"
    , "RUN"
    ]
```

{(fixed|}

```elm {m}
part2 : String
part2 =
    droidProg2
        |> springscript
        |> activateDroid
        |> droidReport
```

{|fixed)}

---

## Reflection

I think this was my favourite puzzle so far. Nicely self-contained focussing on predicate logic rather than requiring lots of coding. I think I was lucky to hit on a short solution to part A quite early one while experimenting with the droid. I found it easier to reduce the operations to working with a single register, which also gave a nice short solution.

For part B it took me much longer to arrive at a set of safe rules and I was unable to reduce them to working only with the `J` register, although I did get the rules down to 8 operations.

Looking at [this solution on reddit](https://www.reddit.com/r/adventofcode/comments/edll5a/2019_day_21_solutions/fbizudo/), it would appear that there is a 6-statement, single register solution:

    [ "NOT H J"
    , "OR  C J"
    , "AND B J"
    , "AND A J"
    , "NOT J J"
    , "AND D J"
    , "RUN"]

which seems remarkably elegant. Not sure I'd have been able to come up with this though.
