---
follows: data/d18_2019.md

id: "litvis"
---

@import "../css/aoc.less"

# Day 18 (2019): Many-Worlds Interpretation

'Part One' and 'Part Two' puzzle descriptions and puzzle input from [Advent of Code](https://adventofcode.com/2019/day/18):

{( part1|}

As you approach Neptune, a planetary security system detects you and activates a giant tractor beam on Triton! You have no choice but to land.

A scan of the local area reveals only one interesting feature: a massive underground vault. You generate a map of the tunnels (your puzzle input). The tunnels are too narrow to move diagonally.

Only one **entrance** (marked @) is present among the **open passages** (marked .) and stone walls (#), but you also detect an assortment of **keys** (shown as lowercase letters) and **doors** (shown as uppercase letters). Keys of a given letter open the door of the same letter: a opens A, b opens B, and so on. You aren't sure which key you need to disable the tractor beam, so you'll need to **collect all of them**.

For example, suppose you have the following map:

    #########
    #b.A.@.a#
    #########

Starting from the entrance (@), you can only access a large door (A) and a key (a). Moving toward the door doesn't help you, but you can move 2 steps to collect the key, unlocking A in the process:

    #########
    #b.....@#
    #########

Then, you can move 6 steps to collect the only other key, b:

    #########
    #@......#
    #########

So, collecting every key took a total of 8 steps.

Here is a larger example:

    ########################
    #f.D.E.e.C.b.A.@.a.B.c.#
    ######################.#
    #d.....................#
    ########################

The only reasonable move is to take key a and unlock door A:

    ########################
    #f.D.E.e.C.b.....@.B.c.#
    ######################.#
    #d.....................#
    ########################

Then, do the same with key b:

    ########################
    #f.D.E.e.C.@.........c.#
    ######################.#
    #d.....................#
    ########################

...and the same with key c:

    ########################
    #f.D.E.e.............@.#
    ######################.#
    #d.....................#
    ########################

Now, you have a choice between keys d and e. While key e is closer, collecting it now would be slower in the long run than collecting key d first, so that's the best choice:

    ########################
    #f...E.e...............#
    ######################.#
    #@.....................#
    ########################

Finally, collect key e to unlock door E, then collect key f, taking a grand total of **86** steps.

Here are a few more examples:

    ########################
    #...............b.C.D.f#
    #.######################
    #.....@.a.B.c.d.A.e.F.g#
    ########################

Shortest path is 132 steps: b, a, c, d, f, e, g

    #################
    #i.G..c...e..H.p#
    ########.########
    #j.A..b...f..D.o#
    ########@########
    #k.E..a...g..B.n#
    ########.########
    #l.F..d...h..C.m#
    #################

Shortest paths are 136 steps;
one is: a, f, b, j, g, n, h, d, l, o, e, p, c, i, k, m

    ########################
    #@..............ac.GI.b#
    ###d#e#f################
    ###A#B#C################
    ###g#h#i################
    ########################

Shortest paths are 81 steps; one is: a, c, f, i, d, g, b, e, h

**How many steps is the shortest path that collects all of the keys?**

{| part1 )}

## Parsing

Convert input into a grid.

```elm {l}
grid : Grid Char
grid =
    test2Input
        |> List.map String.toList
        |> gFromLists
```

For debugging purposes, it is useful to be able to display the grid:

```elm {l}
display : Grid Char -> List String
display =
    gToLists
        >> List.map (List.intersperse '\u{2006}')
        >> List.map String.fromList
        >> List.map
            (String.replace "." "░"
                >> String.replace "#" "▓"
                >> String.replace "@" "●"
                >> flip (++) "\n"
            )
```

{(fixed|}^^^elm { m=(display grid)}^^^{|fixed)}

## Approach

We know the layout of the maze at the outset and the location of the keys we need to find, so store the keys and their locations:

```elm {l}
getKeys : Grid Char -> Dict Char GridLocation
getKeys =
    gMapWithLocation
        (\loc c ->
            if c >= 'a' && c <= 'z' then
                Just ( c, loc )

            else
                Nothing
        )
        >> gToList
        >> List.filterMap identity
        >> Dict.fromList
```

We also need to find the starting location:

```elm {l}
startLocation : Grid Char -> GridLocation
startLocation =
    gMapWithLocation
        (\loc c ->
            if c == '@' then
                Just loc

            else
                Nothing
        )
        >> gToList
        >> List.filterMap identity
        >> List.head
        >> Maybe.withDefault ( -1, -1 )
```

We can build the list of key dependencies (access to key b requires key a to unlock door etc.) by searching outwards from the start location, accumulating the doors we pass before reaching a key. This assumes that any key behind a locked door is only accessible from the start via that door.

```elm {r}
deps : Dict Char (List Char)
deps =
    findDependencies grid (startLocation grid) Set.empty (getKeys grid) [] Set.empty
        |> Set.toList
        |> Dict.fromList
```

{(fixed|}^^^elm { m=(display grid)}^^^{|fixed)}

```elm {l}
findDependencies :
    Grid Char
    -> GridLocation
    -> Set GridLocation
    -> Dict Char GridLocation
    -> List Char
    -> Set ( Char, List Char )
    -> Set ( Char, List Char )
findDependencies g ( row, col ) visited keysLeft doors keysAndDoors =
    if keysLeft == Dict.empty then
        keysAndDoors

    else if Set.member ( row, col ) visited then
        keysAndDoors

    else
        case gGet ( row, col ) g of
            Just cell ->
                if Dict.member cell keysLeft then
                    findDependencies g
                        ( row, col )
                        visited
                        (Dict.remove cell keysLeft)
                        doors
                        (Set.insert ( cell, doors ) keysAndDoors)

                else if cell >= 'A' && cell <= 'Z' then
                    findDependencies (gSet ( row, col ) '.' g)
                        ( row, col )
                        visited
                        keysLeft
                        (Char.toLower cell :: doors)
                        keysAndDoors

                else if cell == '#' then
                    keysAndDoors

                else
                    findDependencies g ( row, col - 1 ) (Set.insert ( row, col ) visited) keysLeft doors keysAndDoors
                        |> Set.union
                            (findDependencies g ( row, col + 1 ) (Set.insert ( row, col ) visited) keysLeft doors keysAndDoors)
                        |> Set.union
                            (findDependencies g ( row - 1, col ) (Set.insert ( row, col ) visited) keysLeft doors keysAndDoors)
                        |> Set.union
                            (findDependencies g ( row + 1, col ) (Set.insert ( row, col ) visited) keysLeft doors keysAndDoors)

            Nothing ->
                Set.empty |> Debug.log "Fallen out of grid"
```

Once we have the dependencies stored, we can find the shortest paths from any location to any set of keys assuming all doors are unlocked. This searches outwards from a given location until all the given keys are found, returning the shortest distance to each of them.

```elm {l}
distancesToKeys : Set Char -> Dict Char Int
distancesToKeys ks =
    let
        paths ( row, col ) steps visited keysLeft keys =
            if keysLeft == Set.empty then
                keys

            else if Set.member ( row, col ) visited then
                keys

            else
                case gGet ( row, col ) grid of
                    Just cell ->
                        if Set.member cell keysLeft then
                            paths
                                ( row, col )
                                steps
                                visited
                                (Set.remove cell keysLeft)
                                (Set.insert ( cell, steps ) keys)

                        else if cell == '#' then
                            keys

                        else
                            paths ( row, col - 1 ) (steps + 1) (Set.insert ( row, col ) visited) keysLeft keys
                                |> Set.union
                                    (paths ( row, col + 1 ) (steps + 1) (Set.insert ( row, col ) visited) keysLeft keys)
                                |> Set.union
                                    (paths ( row - 1, col ) (steps + 1) (Set.insert ( row, col ) visited) keysLeft keys)
                                |> Set.union
                                    (paths ( row + 1, col ) (steps + 1) (Set.insert ( row, col ) visited) keysLeft keys)

                    Nothing ->
                        Set.empty |> Debug.log "Fallen out of grid"
    in
    paths (startLocation grid) 0 Set.empty ks Set.empty
        |> Set.foldl
            (\( key, steps ) dict ->
                if steps < (Dict.get key dict |> Maybe.withDefault 99999) then
                    Dict.insert key steps dict

                else
                    dict
            )
            Dict.empty
```

```elm {l r}
part1 : Dict Char Int
part1 =
    let
        allKeys =
            getKeys grid
    in
    distancesToKeys (Dict.keys allKeys |> Set.fromList)
```

{( part2 |}

{| part2 )}

## Parsing

## Approach

```elm {l r}
part2 : Int
part2 =
    0
```

### Reflection
