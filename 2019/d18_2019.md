---
follows: data/d18_2019.md

id: "litvis"
---

@import "../css/aoc.less"

# Day 18 (2019): Many-Worlds Interpretation

'Part One' and 'Part Two' puzzle descriptions and puzzle input from [Advent of Code](https://adventofcode.com/2019/day/18):

{( part1|}

As you approach Neptune, a planetary security system detects you and activates a giant tractor beam on Triton! You have no choice but to land.

A scan of the local area reveals only one interesting feature: a massive underground vault. You generate a map of the tunnels (your puzzle input). The tunnels are too narrow to move diagonally.

Only one **entrance** (marked @) is present among the **open passages** (marked .) and stone walls (#), but you also detect an assortment of **keys** (shown as lowercase letters) and **doors** (shown as uppercase letters). Keys of a given letter open the door of the same letter: a opens A, b opens B, and so on. You aren't sure which key you need to disable the tractor beam, so you'll need to **collect all of them**.

For example, suppose you have the following map:

```txt
#########
#b.A.@.a#
#########
```

Starting from the entrance (@), you can only access a large door (A) and a key (a). Moving toward the door doesn't help you, but you can move 2 steps to collect the key, unlocking A in the process:

```txt
#########
#b.....@#
#########
```

Then, you can move 6 steps to collect the only other key, b:

```txt
#########
#@......#
#########
```

So, collecting every key took a total of 8 steps.

Here is a larger example:

```txt
########################
#f.D.E.e.C.b.A.@.a.B.c.#
######################.#
#d.....................#
########################
```

The only reasonable move is to take key a and unlock door A:

```txt
########################
#f.D.E.e.C.b.....@.B.c.#
######################.#
#d.....................#
########################
```

Then, do the same with key b:

```txt
########################
#f.D.E.e.C.@.........c.#
######################.#
#d.....................#
########################
```

...and the same with key c:

```txt
########################
#f.D.E.e.............@.#
######################.#
#d.....................#
########################
```

Now, you have a choice between keys d and e. While key e is closer, collecting it now would be slower in the long run than collecting key d first, so that's the best choice:

```txt
########################
#f...E.e...............#
######################.#
#@.....................#
########################
```

Finally, collect key e to unlock door E, then collect key f, taking a grand total of **86** steps.

Here are a few more examples:

```txt
########################
#...............b.C.D.f#
#.######################
#.....@.a.B.c.d.A.e.F.g#
########################
```

Shortest path is 132 steps: b, a, c, d, f, e, g

```txt
#################
#i.G..c...e..H.p#
########.########
#j.A..b...f..D.o#
########@########
#k.E..a...g..B.n#
########.########
#l.F..d...h..C.m#
#################
```

Shortest paths are 136 steps;
one is: a, f, b, j, g, n, h, d, l, o, e, p, c, i, k, m

```txt
########################
#@..............ac.GI.b#
###d#e#f################
###A#B#C################
###g#h#i################
########################
```

Shortest paths are 81 steps; one is: a, c, f, i, d, g, b, e, h

**How many steps is the shortest path that collects all of the keys?**

{| part1 )}

## Parsing

Convert input into a grid.

```elm {l}
grid : AOC.Grid Char
grid =
    --test5Input
    puzzleInput
        |> List.map String.toList
        |> AOC.gFromLists
```

For debugging purposes, it is useful to be able to display the grid:

```elm {l}
display : AOC.Grid Char -> List String
display =
    AOC.gToLists
        >> List.map (List.intersperse '\u{2006}')
        >> List.map String.fromList
        >> List.map
            (String.replace "." "░"
                >> String.replace "#" "▓"
                >> String.replace "@" "●"
                >> AOC.flip (++) "\n"
            )
```

{(fixed|}^^^elm { m=(display grid)}^^^{|fixed)}

## Approach

For convenience, we can store the location of the start and all key locations:

```elm {l}
keyLocations : AOC.Grid Char -> Dict Char AOC.GridLocation
keyLocations =
    AOC.gMapWithLocation
        (\loc c ->
            if c == '@' || (c >= 'a' && c <= 'z') then
                Just ( c, loc )

            else
                Nothing
        )
        >> AOC.gToList
        >> List.filterMap identity
        >> Dict.fromList


allKeys : List Char
allKeys =
    Dict.keys (keyLocations grid)
```

Generally, navigating the grid maze is expensive, so we can represent the maze as a graph of keys with edges representing the number of steps between them along their connecting path assuming all doors are open. We will also store any intermediate doors for later navigation.

```elm {l}
adjacentKeys : Char -> AOC.Grid Char -> List ( Char, Int, List Char )
adjacentKeys key tunnels =
    let
        ( keyRow, keyCol ) =
            Dict.get key (keyLocations tunnels) |> Maybe.withDefault ( -1, -1 )

        addNeighbour grd ( r, c ) ( steps, doors ) =
            case AOC.gGet ( r, c ) grd of
                Just cell ->
                    if cell == '#' then
                        identity

                    else
                        Deque.pushBack ( r, c, ( steps, doors ) )

                Nothing ->
                    identity

        paths grd todo adjKeys =
            case Deque.popFront todo of
                ( Nothing, _ ) ->
                    adjKeys

                ( Just ( r, c, ( steps, doors ) ), todo2 ) ->
                    case AOC.gGet ( r, c ) grd of
                        Just cell ->
                            if cell == '#' then
                                paths grd todo2 adjKeys

                            else if cell >= 'A' && cell <= 'Z' then
                                paths
                                    (AOC.gSet ( r, c ) '#' grd)
                                    (todo2
                                        |> addNeighbour grd ( r - 1, c ) ( steps + 1, Char.toLower cell :: doors )
                                        |> addNeighbour grd ( r + 1, c ) ( steps + 1, Char.toLower cell :: doors )
                                        |> addNeighbour grd ( r, c - 1 ) ( steps + 1, Char.toLower cell :: doors )
                                        |> addNeighbour grd ( r, c + 1 ) ( steps + 1, Char.toLower cell :: doors )
                                    )
                                    adjKeys

                            else if cell == '.' || cell == key then
                                paths
                                    (AOC.gSet ( r, c ) '#' grd)
                                    (todo2
                                        |> addNeighbour grd ( r - 1, c ) ( steps + 1, doors )
                                        |> addNeighbour grd ( r + 1, c ) ( steps + 1, doors )
                                        |> addNeighbour grd ( r, c - 1 ) ( steps + 1, doors )
                                        |> addNeighbour grd ( r, c + 1 ) ( steps + 1, doors )
                                    )
                                    adjKeys

                            else
                                paths grd todo2 (( cell, steps, doors ) :: adjKeys)

                        Nothing ->
                            -- We should never get here
                            adjKeys
    in
    paths
        tunnels
        (Deque.singleton ( keyRow, keyCol, ( 0, [] ) ))
        []
```

To build the graph representing the tunnels we add all the edges between all keys and their adjacent neighbours. At the same time we can build a dictionary of edges that contain one or more doors between them. For clarity we will store both the graph and the dictionary of edge doors in a single record.

```elm {l}
type alias Tunnels =
    { g : AOC.SPFGraph Char
    , d : Dict ( Char, Char ) (List Char)
    }
```

```elm {l}
buildGraph : Tunnels
buildGraph =
    let
        ( graph, dict ) =
            keyLocations grid
                |> Dict.keys
                |> List.foldl
                    (\fromKey ( g, d ) ->
                        let
                            keysAndDoors =
                                adjacentKeys fromKey grid
                        in
                        ( keysAndDoors
                            |> List.foldl
                                (\( toKey, steps, _ ) ->
                                    AOC.addDirectedEdge fromKey toKey (toFloat steps)
                                )
                                g
                        , keysAndDoors
                            |> List.foldl
                                (\( toKey, _, doors ) edgeDoors ->
                                    if doors == [] then
                                        edgeDoors

                                    else
                                        Dict.insert ( fromKey, toKey ) doors edgeDoors
                                )
                                d
                        )
                    )
                    ( Graph.empty, Dict.empty )
    in
    Tunnels graph dict
```

From this it is easy to create a sub-graph that contains all connected keys given a set of carried keys (i.e. remove edges that are blocked by a door for which we don't have a key).

```elm {l}
accessibleTunnels : Set Char -> Tunnels -> AOC.SPFGraph Char
accessibleTunnels carried tunnels =
    let
        edges =
            Graph.edges tunnels.g

        removeClosed ( k1, k2 ) g =
            case Dict.get ( k1, k2 ) tunnels.d of
                Just doors ->
                    if List.all (\door -> Set.member door carried) doors then
                        g

                    else
                        Graph.removeEdge k1 k2 g

                Nothing ->
                    g

        subGraph =
            List.foldl removeClosed tunnels.g edges
    in
    subGraph
```

Now we have a navigable graph representing the maze with any given collection of carried keys, we can more efficiently determine any key's uncollected adjacent keys and their shortest paths to each of them. We can use Dijkstra's SPF on graph to find the shortest paths.

```elm {l}
uncollectedAdjacentKeys : Char -> Set Char -> Tunnels -> Set ( Char, Int )
uncollectedAdjacentKeys fromKey carried tunnels =
    let
        gAccess =
            accessibleTunnels carried tunnels

        keyDist toKey =
            ( toKey, AOC.shortestPathCost fromKey toKey gAccess |> Maybe.withDefault 0 |> round )

        member set k =
            Set.member k set

        search todo visited adj =
            case Set.toList todo of
                k1 :: tl ->
                    let
                        ( newTodo, newAdj ) =
                            Set.partition (member carried)
                                (Graph.outgoing k1 gAccess |> Set.filter (not << member visited))
                                |> Tuple.mapSecond (AOC.flip Set.diff (Set.map Tuple.first adj))
                    in
                    search (Set.union newTodo (Set.fromList tl))
                        (Set.insert k1 visited)
                        (Set.union (newAdj |> Set.map keyDist) adj)

                [] ->
                    adj
    in
    search (Set.singleton fromKey) Set.empty Set.empty
```

We can now start storing paths to sequences of keys originating at the start location. We need to keep track of three pieces of information: the latest key picked up; the keys carried to that point, including the latest key; and the number of steps taken to reach this key. We can store this in a dictionary where the id is tuple of an alphabetical list of carried keys with the current key, and the value associated with it is the number of steps taken. If in our search we come across the same set of collected keys at a key location that we have seen before, we just store the shorter of the two.

```elm {l}
buildPaths : Dict ( String, Char ) Int
buildPaths =
    let
        tunnels =
            buildGraph

        carriedId =
            Set.fromList >> Set.toList >> String.fromList

        search ( todo, paths ) =
            case todo of
                [] ->
                    paths

                ( carried, dist ) :: tl ->
                    let
                        fromKey =
                            List.head carried |> Maybe.withDefault '@'

                        toKeys =
                            uncollectedAdjacentKeys fromKey (Set.fromList carried) tunnels

                        addPath ( k, d ) ( td, ps ) =
                            let
                                id =
                                    carriedId (k :: carried)

                                d2 =
                                    dist + d
                            in
                            case Dict.get ( id, k ) ps of
                                Nothing ->
                                    ( ( k :: carried, d2 ) :: td, Dict.insert ( id, k ) d2 ps )

                                Just oldDist ->
                                    if d2 < oldDist then
                                        ( ( k :: carried, d2 ) :: td, Dict.insert ( id, k ) d2 ps )

                                    else
                                        ( td, ps )
                    in
                    search (Set.foldl addPath ( tl, paths ) toKeys)
    in
    search ( [ ( [ '@' ], 0 ) ], Dict.empty )
```

Finally we filter all pathways to just those that end up with all keys carried and select the one with the shortest distance.

```elm {l r}
part1 : Int
part1 =
    buildPaths
        |> Dict.toList
        |> List.filter (\( ( carried, _ ), _ ) -> carried == String.fromList allKeys)
        |> List.map Tuple.second
        |> List.minimum
        |> Maybe.withDefault 0
```

{( part2 |}

You arrive at the vault only to discover that there is not one vault, but **four** - each with its own entrance.

On your map, find the area in the middle that looks like this:

```txt
...
.@.
...
```

Update your map to instead use the correct data:

```txt
@#@
###
@#@
```

This change will split your map into four separate sections, each with its own entrance:

```txt
#######       #######
#a.#Cd#       #a.#Cd#
##...##       ##@#@##
##.@.##  -->  #######
##...##       ##@#@##
#cB#Ab#       #cB#Ab#
#######       #######
```

Because some of the keys are for doors in other vaults, it would take much too long to collect all of the keys by yourself. Instead, you deploy four remote-controlled robots. Each starts at one of the entrances (@).

Your goal is still to **collect all of the keys in the fewest steps**, but now, each robot has its own position and can move independently. You can only remotely control a single robot at a time. Collecting a key instantly unlocks any corresponding doors, regardless of the vault in which the key or door is found.

For example, in the map above, the top-left robot first collects key a, unlocking door A in the bottom-right vault:

```txt
#######
#@.#Cd#
##.#@##
#######
##@#@##
#cB#.b#
#######
```

Then, the bottom-right robot collects key b, unlocking door B in the bottom-left vault:

```txt
#######
#@.#Cd#
##.#@##
#######
##@#.##
#c.#.@#
#######
```

Then, the bottom-left robot collects key c:

```txt
#######
#@.#.d#
##.#@##
#######
##.#.##
#@.#.@#
#######
```

Finally, the top-right robot collects key d:

```txt
#######
#@.#.@#
##.#.##
#######
##.#.##
#@.#.@#
#######
```

In this example, it only took **8** steps to collect all of the keys.

Sometimes, multiple robots might have keys available, or a robot might have to wait for multiple keys to be collected:

```txt
###############
#d.ABC.#.....a#
######@#@######
###############
######@#@######
#b.....#.....c#
###############
```

First, the top-right, bottom-left, and bottom-right robots take turns collecting keys a, b, and c, a total of 6 + 6 + 6 = 18 steps. Then, the top-left robot can access key d, spending another 6 steps; collecting all of the keys here takes a minimum of **24** steps.

Here's a more complex example:

```txt
#############
#DcBa.#.GhKl#
#.###@#@#I###
#e#d#####j#k#
###C#@#@###J#
#fEbA.#.FgHi#
#############
```

- Top-left robot collects key a.
- Bottom-left robot collects key b.
- Top-left robot collects key c.
- Bottom-left robot collects key d.
- Top-left robot collects key e.
- Bottom-left robot collects key f.
- Bottom-right robot collects key g.
- Top-right robot collects key h.
- Bottom-right robot collects key i.
- Top-right robot collects key j.
- Bottom-right robot collects key k.
- Top-right robot collects key l.

In the above example, the fewest steps to collect all of the keys is **32**.

Here's an example with more choices:

```txt
#############
#g#f.D#..h#l#
#F###e#E###.#
#dCba@#@BcIJ#
#############
#nK.L@#@G...#
#M###N#H###.#
#o#m..#i#jk.#
#############
```

One solution with the fewest steps is:

- Top-left robot collects key e.
- Top-right robot collects key h.
- Bottom-right robot collects key i.
- Top-left robot collects key a.
- Top-left robot collects key b.
- Top-right robot collects key c.
- Top-left robot collects key d.
- Top-left robot collects key f.
- Top-left robot collects key g.
- Bottom-right robot collects key k.
- Bottom-right robot collects key j.
- Top-right robot collects key l.
- Bottom-left robot collects key n.
- Bottom-left robot collects key m.
- Bottom-left robot collects key o.

This example requires at least **72** steps to collect all keys.

After updating your map and using the remote-controlled robots, **what is the fewest steps necessary to collect all of the keys**?

{| part2 )}

## Approach Part Two

```elm {l r}
part2 : Int
part2 =
    0
```

---

## Reflection

This puzzle was too much for me in my limited time in December so I revisited it later in the year. Even with the lack of time pressure, this was tough and it took me several attempts to land on a workable solution. It was satisfying to finally come up with a solution that was reasonably efficient after spending so much time on the problem. I remain in awe of those who can solve these kinds of problems so quickly.

My first attempt at part one involved calculating key-dependencies (key f needs key d which needs k c etc.), but this soon proved too costly as there are many permutations of key pickup.

My second attempt tried to simplify the problem by finding the distance between all adjacent keys, recognising that the maze was as acyclic. But again this proved too costly for the full puzzle input (and example 4) where the number of key pair permutations was large and had to be recalculated many times to explore all possible pathways through the maze.

My third attempt was similar to the working solution except that I calculated the pathways by navigating the gridded maze. This was generating the correct results for the example inputs, but was taking too long for example 4 and the puzzle input (many minutes).

Finally, representing the key network as a graph led to significant speed ups. This also made it easier to use a Dijkstra SPF search to build find the shortest path between non-adjacent keys, further speeding up the solution that only stored the shortest route for a given set of collected keys at each key location. Using this method the correct result for part 1 is found in around 7 seconds.

A byproduct of tacking this problem was that I added a Dijkstra/A\* solver to the AOC module, which may be helpful for other graph searching problems.

Test 4 (the fourth example in the part 1 instructions) takes about 8 times as long to complete than the actual puzzle input. Presumably because if the 8 keys all accessible from the centre without the need for opening any doors. This suggests that some further pruning of pathways might be possible to reduce search space. But given a reasonably fast solution for the puzzle input, I've not investigated this.
