---
follows: data/d16_2019.md

id: "litvis"
---

@import "../css/aoc.less"

# Day 16 (2019): Flawed Frequency Transmission

'Part One' and 'Part Two' puzzle descriptions and puzzle input from [Advent of Code](https://adventofcode.com/2019/day/16):

{( part1|}

You're 3/4ths of the way through the gas giants. Not only do roundtrip signals to Earth take five hours, but the signal quality is quite bad as well. You can clean up the signal with the Flawed Frequency Transmission algorithm, or **FFT**.

As input, FFT takes a list of numbers. In the signal you received (your puzzle input), each number is a single digit: data like 15243 represents the sequence 1, 5, 2, 4, 3.

FFT operates in repeated **phases**. In each phase, a new list is constructed with the same length as the input list. This new list is also used as the input for the next phase.

Each element in the new list is built by multiplying every value in the input list by a value in a repeating **pattern** and then adding up the results. So, if the input list were 9, 8, 7, 6, 5 and the pattern for a given element were 1, 2, 3, the result would be 9\*1 + 8\*2 + 7\*3 + 6\*1 + 5\*2 (with each input element on the left and each value in the repeating pattern on the right of each multiplication). Then, only the ones digit is kept: 38 becomes 8, -17 becomes 7, and so on.

While each element in the output array uses all of the same input array elements, the actual repeating pattern to use depends on **which output element** is being calculated. The base pattern is 0, 1, 0, -1. Then, repeat each value in the pattern a number of times equal to the **position in the output list** being considered. Repeat once for the first element, twice for the second element, three times for the third element, and so on. So, if the third element of the output list is being calculated, repeating the values would produce: 0, 0, 0, 1, 1, 1, 0, 0, 0, -1, -1, -1.

When applying the pattern, skip the very first value exactly once. (In other words, offset the whole pattern left by one.) So, for the second element of the output list, the actual pattern used would be: 0, 1, 1, 0, 0, -1, -1, 0, 0, 1, 1, 0, 0, -1, -1, ....

After using this process to calculate each element of the output list, the phase is complete, and the output list of this phase is used as the new input list for the next phase, if any.

Given the input signal 12345678, below are four phases of FFT. Within each phase, each output digit is calculated on a single line with the result at the far right; each multiplication operation shows the input digit on the left and the pattern value on the right:

Input signal: 12345678

    1*1 + 2*0 + 3*-1 + 4*0 + 5*1 + 6*0  + 7*-1 + 8*0 = 4
    1*0 + 2*1 + 3*1  + 4*0 + 5*0 + 6*-1 + 7*-1 + 8*0 = 8
    1*0 + 2*0 + 3*1  + 4*1 + 5*1 + 6*0  + 7*0  + 8*0 = 2
    1*0 + 2*0 + 3*0  + 4*1 + 5*1 + 6*1  + 7*1  + 8*0 = 2
    1*0 + 2*0 + 3*0  + 4*0 + 5*1 + 6*1  + 7*1  + 8*1 = 6
    1*0 + 2*0 + 3*0  + 4*0 + 5*0 + 6*1  + 7*1  + 8*1 = 1
    1*0 + 2*0 + 3*0  + 4*0 + 5*0 + 6*0  + 7*1  + 8*1 = 5
    1*0 + 2*0 + 3*0  + 4*0 + 5*0 + 6*0  + 7*0  + 8*1 = 8

After 1 phase: 48226158

    4*1 + 8*0 + 2*-1 + 2*0 + 6*1 + 1*0  + 5*-1 + 8*0 = 3
    4*0 + 8*1 + 2*1  + 2*0 + 6*0 + 1*-1 + 5*-1 + 8*0 = 4
    4*0 + 8*0 + 2*1  + 2*1 + 6*1 + 1*0  + 5*0  + 8*0 = 0
    4*0 + 8*0 + 2*0  + 2*1 + 6*1 + 1*1  + 5*1  + 8*0 = 4
    4*0 + 8*0 + 2*0  + 2*0 + 6*1 + 1*1  + 5*1  + 8*1 = 0
    4*0 + 8*0 + 2*0  + 2*0 + 6*0 + 1*1  + 5*1  + 8*1 = 4
    4*0 + 8*0 + 2*0  + 2*0 + 6*0 + 1*0  + 5*1  + 8*1 = 3
    4*0 + 8*0 + 2*0  + 2*0 + 6*0 + 1*0  + 5*0  + 8*1 = 8

After 2 phases: 34040438

    3*1 + 4*0 + 0*-1 + 4*0 + 0*1 + 4*0  + 3*-1 + 8*0 = 0
    3*0 + 4*1 + 0*1 +  4*0 + 0*0 + 4*-1 + 3*-1 + 8*0 = 3
    3*0 + 4*0 + 0*1 +  4*1 + 0*1 + 4*0  + 3*0  + 8*0 = 4
    3*0 + 4*0 + 0*0 +  4*1 + 0*1 + 4*1  + 3*1  + 8*0 = 1
    3*0 + 4*0 + 0*0 +  4*0 + 0*1 + 4*1  + 3*1  + 8*1 = 5
    3*0 + 4*0 + 0*0 +  4*0 + 0*0 + 4*1  + 3*1  + 8*1 = 5
    3*0 + 4*0 + 0*0 +  4*0 + 0*0 + 4*0  + 3*1  + 8*1 = 1
    3*0 + 4*0 + 0*0 +  4*0 + 0*0 + 4*0  + 3*0  + 8*1 = 8

After 3 phases: 03415518

    0*1 + 3*0 + 4*-1 + 1*0 + 5*1 + 5*0  + 1*-1 + 8*0 = 0
    0*0 + 3*1 + 4*1  + 1*0 + 5*0 + 5*-1 + 1*-1 + 8*0 = 1
    0*0 + 3*0 + 4*1  + 1*1 + 5*1 + 5*0  + 1*0  + 8*0 = 0
    0*0 + 3*0 + 4*0  + 1*1 + 5*1 + 5*1  + 1*1  + 8*0 = 2
    0*0 + 3*0 + 4*0  + 1*0 + 5*1 + 5*1  + 1*1  + 8*1 = 9
    0*0 + 3*0 + 4*0  + 1*0 + 5*0 + 5*1  + 1*1  + 8*1 = 4
    0*0 + 3*0 + 4*0  + 1*0 + 5*0 + 5*0  + 1*1  + 8*1 = 9
    0*0 + 3*0 + 4*0  + 1*0 + 5*0 + 5*0  + 1*0  + 8*1 = 8

After 4 phases: 01029498

Here are the first eight digits of the final output list after 100 phases for some larger inputs:

80871224585914546619083218645595 becomes 24176176.
19617804207202209144916044189917 becomes 73745418.
69317163492948606335995924319873 becomes 52432133.

After 100 phases of FFT, **what are the first eight digits in the final output list?**

{| part1 )}

## Parsing

Convert a string of digits into a list of integers.

```elm {l}
parse : String -> List Int
parse =
    String.toList
        >> List.filterMap (String.fromChar >> String.toInt)
```

## Approach

We can find the repeating pattern multipliers by repeating each digit of the base pattern 'position' times, For cases where the resulting list is shorter than the input length, we repeat the entire sequence sufficient times to at least match the input length.

In the worst case, this leads to generation of a list just under 4 times the length of the input before we extract the coefficients.

```elm {l}
coeffs : Int -> Int -> List Int
coeffs position len =
    let
        repeatedPattern =
            List.concatMap (List.repeat position) [ 0, 1, 0, -1 ]
    in
    List.repeat (1 + len // List.length repeatedPattern) repeatedPattern
        |> List.concat
        |> List.drop 1
        |> List.take len
```

```elm {l}
phase : List Int -> List Int
phase input =
    let
        row pos =
            List.map2 (*) input (coeffs pos (List.length input))
                |> List.sum
                |> remainderBy 10
                |> abs
    in
    List.map row (List.range 1 (List.length input))
```

```elm {l r}
part1 : String
part1 =
    AOC.iterate 100 (parse puzzleInput) phase
        |> List.take 8
        |> List.map String.fromInt
        |> String.concat
```

{( part2 |}

Now that your FFT is working, you can decode the **real signal.**

The real signal is your puzzle input repeated 10000 times. Treat this new signal as a single input list. Patterns are still calculated as before, and 100 phases of FFT are still applied.

The **first seven digits** of your initial input signal also represent the **message offset**. The message offset is the location of the eight-digit message in the final output list. Specifically, the message offset indicates the **number of digits to skip** before reading the eight-digit message. For example, if the first seven digits of your initial input signal were 1234567, the eight-digit message would be the eight digits after skipping 1,234,567 digits of the final output list. Or, if the message offset were 7 and your final output list were 98765432109876543210, the eight-digit message would be 21098765. (Of course, your real message offset will be a seven-digit number, not a one-digit number like 7.)

Here is the eight-digit message in the final output list after 100 phases. The message offset given in each input has been highlighted. (Note that the inputs given below are repeated 10000 times to find the actual starting input lists.)

- **0303673**2577212944063491565474664 becomes 84462026.
- **0293510**9699940807407585447034323 becomes 78725270.
- **0308177**0884921959731165446850517 becomes 53553731.

After repeating your input signal 10000 times and running 100 phases of FFT, **what is the eight-digit message embedded in the final output list?**

{| part2 )}

## Approach Part Two

It is clear from the vastly increased signal length, that for part 2 we cannot simply iterate the part 1 solution.

Looking for patterns that might give a clue for a more efficient algorithm, we can show the base pattern used as a multiplier for the digit at each position in the signal.

| position | 1   | 2   | 3   | 4   | 5   | 6   | 7   | 8   | 9   | 10  | 11  | 12  | 13  | 14  | 15  | 16  | 17  | 18  |
| -------- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| **1**    | 1   | 0   | -1  | 0   | 1   | 0   | -1  | 0   | 1   | 0   | -1  | 0   | 1   | 0   | -1  | 0   | 1   | 0   |
| **2**    | 0   | 1   | 1   | 0   | 0   | -1  | -1  | 0   | 0   | 1   | 1   | 0   | 0   | -1  | -1  | 0   | 0   | 1   |
| **3**    | 0   | 0   | 1   | 1   | 1   | 0   | 0   | 0   | -1  | -1  | -1  | 0   | 0   | 0   | 1   | 1   | 1   | 0   |
| **4**    | 0   | 0   | 0   | 1   | 1   | 1   | 1   | 0   | 0   | 0   | 0   | -1  | -1  | -1  | -1  | 0   | 0   | 0   |
| **5**    | 0   | 0   | 0   | 0   | 1   | 1   | 1   | 1   | 1   | 0   | 0   | 0   | 0   | 0   | -1  | -1  | -1  | -1  |
| **6**    | 0   | 0   | 0   | 0   | 0   | 1   | 1   | 1   | 1   | 1   | 1   | 0   | 0   | 0   | 0   | 0   | 0   | -1  |
| **7**    | 0   | 0   | 0   | 0   | 0   | 0   | 1   | 1   | 1   | 1   | 1   | 1   | 1   | 0   | 0   | 0   | 0   | 0   |
| **8**    | 0   | 0   | 0   | 0   | 0   | 0   | 0   | 1   | 1   | 1   | 1   | 1   | 1   | 1   | 1   | 0   | 0   | 0   |
| **9**    | 0   | 0   | 0   | 0   | 0   | 0   | 0   | 1   | 1   | 1   | 1   | 1   | 1   | 1   | 1   | 1   | 0   | 0   |
| **10**   | 0   | 0   | 0   | 0   | 0   | 0   | 0   | 0   | 0   | 1   | 1   | 1   | 1   | 1   | 1   | 1   | 1   | 1   |
| **11**   | 0   | 0   | 0   | 0   | 0   | 0   | 0   | 0   | 0   | 0   | 1   | 1   | 1   | 1   | 1   | 1   | 1   | 1   |
| **12**   | 0   | 0   | 0   | 0   | 0   | 0   | 0   | 0   | 0   | 0   | 0   | 1   | 1   | 1   | 1   | 1   | 1   | 1   |
| **13**   | 0   | 0   | 0   | 0   | 0   | 0   | 0   | 0   | 0   | 0   | 0   | 0   | 1   | 1   | 1   | 1   | 1   | 1   |
| **14**   | 0   | 0   | 0   | 0   | 0   | 0   | 0   | 0   | 0   | 0   | 0   | 0   | 0   | 1   | 1   | 1   | 1   | 1   |
| **15**   | 0   | 0   | 0   | 0   | 0   | 0   | 0   | 0   | 0   | 0   | 0   | 0   | 0   | 0   | 1   | 1   | 1   | 1   |
| **16**   | 0   | 0   | 0   | 0   | 0   | 0   | 0   | 0   | 0   | 0   | 0   | 0   | 0   | 0   | 0   | 1   | 1   | 1   |
| **17**   | 0   | 0   | 0   | 0   | 0   | 0   | 0   | 0   | 0   | 0   | 0   | 0   | 0   | 0   | 0   | 0   | 1   | 1   |
| **18**   | 0   | 0   | 0   | 0   | 0   | 0   | 0   | 0   | 0   | 0   | 0   | 0   | 0   | 0   | 0   | 0   | 0   | 1   |

We can note a couple of useful properties from this example:

- The new signal at any given position is independent of any digits in earlier positions (all 0s). This means for a a given offset, we can ignore any digits prior to that position.
- The last digit of the new signal (18th in example above) will just be the last digit of the input signal (all other multipliers are 0). For the penultimate digit it is the sum of the last two digits, the third from last the sum of the last three digits etc. This pattern holds for the final 9 digits of an 18 digit sequence.

And so it appears to be the case that for any offset that falls in the second half of the sequence we have an efficiently computable solution. We can check whether for any given input signal repeated 10000 times, the offset position (first seven digits of signal) is in the second half of the sequence:

```elm {l}
offset : String -> Int
offset =
    String.left 7 >> String.toInt >> Maybe.withDefault 0


inSecondHalf : String -> Bool
inSecondHalf signal =
    offset signal >= (10000 * String.length signal // 2)
```

Part 2 example 1: ^^^elm {m=(inSecondHalf testInput5)}^^^

Part 2 example 2: ^^^elm {m=(inSecondHalf testInput6)}^^^
Part 2 example 3: ^^^elm {m=(inSecondHalf testInput7)}^^^
Puzzle input: ^^^elm {m=(inSecondHalf puzzleInput)}^^^

We can fold and accumulate totals to find the new signals for each iteration:

```elm {l}
phase2 : List Int -> List Int
phase2 signal =
    AOC.scanl (\n -> (+) n >> modBy 10) 0 (signal |> List.reverse)
        |> List.drop 1
        |> List.reverse
```

Iterating 100 times with this new approach to calculating the modified signal should give us the correct answer but applying it to the entire input signal is wasteful as we are only interested in the digits from the offset (indicated by first 7 digits of input) to the end of the list. So to we calculate the initial truncated signal from offset to end:

```elm {l}
initSignal : String -> List Int
initSignal input =
    let
        inLen =
            String.length input

        numRepeats =
            (10001 * inLen - offset input) // inLen

        off =
            modBy (String.length input) (offset input)
    in
    input
        |> List.repeat numRepeats
        |> String.concat
        |> parse
        |> List.drop off
```

Extracting the first 8 digits from processed signal gives us the answer:

```elm {l r}
part2 : String
part2 =
    let
        input =
            initSignal puzzleInput
    in
    AOC.iterate 100 input phase2
        |> List.take 8
        |> List.map String.fromInt
        |> String.concat
```

---

## Reflection

Another puzzle where I didn't have time to complete part 2 in December.

Part one afforded a literal interpretation of the question and computes the answer in a couple of seconds. But it lulled me into thinking the optimisation required for part 2, which was clearly not computable via brute force computation of multi-thousand digit numbers, would be to look for repeated sequences in the earlier part of the signal.

After struggling to find a pattern in the output signal, I then looked just at the coefficients as laid out in the table above. This helped direct me to a more efficient solution. I spent longer than I wished debugging my code for trimming the input code as the integer division used to find the minimum number of repeats underestimated for the final test case (and puzzle input) despite working correctly for the first two tests.
