---
follows: data/d02_2018.md

id: "litvis"
---

@import "../css/aoc.less"

# Day 2 (2018): Inventory Management System

'Part One' and 'Part Two' puzzle descriptions and puzzle input from [Advent of Code](https://adventofcode.com/2018/day/2).

{( part1|}

What is the checksum for your list of box IDs?

{| part1 )}

We will need to count the number of possibly repeated letters in each box ID, which we can do by converting each string into a list of characters and building a frequency table (from [aoc.md](aoc.md))

```elm {l}
letterFreqs : String -> Dict Char Int
letterFreqs =
    String.toList >> List.foldl AOC.addToFreqTable Dict.empty
```

We can then select strings that contain a given frequency of repeated letters

```elm {l}
withRepeats : Int -> List String -> List String
withRepeats n =
    List.filter (letterFreqs >> Dict.values >> List.member n)
```

## Testing

The question provides us with a test case to check things work as expected (4 IDs with two repeated letters and 3 IDs with three repeated letters):

```elm {l r siding}
test : List (List String)
test =
    let
        input =
            [ "abcdef", "bababc", "abbcde", "abcccd", "aabcdd", "abcdee", "ababab" ]
    in
    [ withRepeats 2 input, withRepeats 3 input ]
```

And now we can apply it to the input puzzle data.

```elm {l r}
part1 : Int
part1 =
    List.length (withRepeats 2 puzzleInput) * List.length (withRepeats 3 puzzleInput)
```

{( part2 |}

What letters are common between the two correct box IDs?

{| part2 )}

To answer the question we will need to compare each string with every other one (from the set of IDs containing two or three repeated letters). We can use `pairwiseCombinations` from [Aoc.elm](../src/Aoc.elm) to select all such combinations. We can then identify whether a pair of strings differs by only one character.

```elm {l}
diffByOnePairs : List String -> List ( String, String )
diffByOnePairs =
    let
        diffByOne ( strA, strB ) =
            (List.map2 (/=) (String.toList strA) (String.toList strB)
                |> List.filter identity
                |> List.length
            )
                == 1
    in
    AOC.pairwiseCombinations >> List.filter diffByOne
```

Once we have a pair of strings that differ by one character, we just need to identify their common characters:

```elm {l}
commonChrs : ( String, String ) -> String
commonChrs ( strA, strB ) =
    List.map2 Tuple.pair (String.toList strA) (String.toList strB)
        |> List.filter (\( a, b ) -> a == b)
        |> List.map Tuple.first
        |> String.fromList
```

## Testing Part 2

Again, the question provides us with a simple list of strings to test that should generate a single string `fgij`:

```elm {l r siding}
test : List String
test =
    [ "abcde", "fghij", "klmno", "pqrst", "fguij", "axcye", "wvxyz" ]
        |> diffByOnePairs
        |> List.map commonChrs
```

Now we can apply the same process to the puzzle input:

```elm {l r}
part2 : List String
part2 =
    (withRepeats 2 puzzleInput ++ withRepeats 3 puzzleInput)
        |> AOC.unique
        |> diffByOnePairs
        |> List.map commonChrs
```

## Optimisation

The approach above is an O(n^2) process (generated by all pairwise combinations). A more efficient process could achieve the same result by sequentially storing in a set, each ID with the first character removed looking for match. If a match is found, this is the answer. If not, try with the second character removed etc.
