---
follows: data/d25_2020.md

id: "litvis"
---

@import "../css/aoc.less"

# Day 25 (2020): Combo Breaker

'Part One' and 'Part Two' puzzle descriptions and puzzle input from [Advent of Code](https://adventofcode.com/2020/day/25)

{(part1|}

**What encryption key is the handshake trying to establish?**

{|part1)}

Firstly store the card and door's public keys:

```elm {l}
parse : String -> ( Int, Int )
parse input =
    case String.lines input of
        [ cardPK, doorPK ] ->
            ( AOC.toInt cardPK, AOC.toInt doorPK )

        _ ->
            ( 1, 1 ) |> Debug.log "Bad input"
```

The core cryptographic transformation that will be iteratively applied to a subject number, _loop number_ of times:

```elm {l}
trans : Int -> Int -> Int
trans sn v =
    modBy 20201227 (sn * v)
```

To find the loop number of the card (or door), we can iteratively apply the transformation of 7 until it matches a card's (or door's) public key.

```elm {l}
loopToKey : Int -> Int -> Int -> Int
loopToKey pubKey n v =
    if v == pubKey then
        n

    else
        loopToKey pubKey (n + 1) (trans 7 v)
```

Now we know the loop number, we can apply the transformation to the door's (or card's) public key that number of times in order to find the private encryption key.

```elm {l r}
part1 : Int
part1 =
    let
        ( cardPubKey, doorPubKey ) =
            parse puzzleInput
    in
    AOC.iterate (loopToKey cardPubKey 0 1) 1 (trans doorPubKey)
```

---

## Reflection

A simpler than usual final day puzzle which can be solved with brute force iteration in under a second. Perhaps there is a more efficient way of establishing the loop size, but it does not seem necessary for the puzzle input.
