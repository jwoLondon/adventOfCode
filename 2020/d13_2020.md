---
follows: data/d13_2020.md

id: "litvis"
---

@import "../css/aoc.less"

# Day 13 (2020): Shuttle Search

'Part One' and 'Part Two' puzzle descriptions and puzzle input from [Advent of Code](https://adventofcode.com/2020/day/13).

{(part1 |}

What is the ID of the earliest bus you can take to the airport multiplied by the number of minutes you'll need to wait for that bus?

{|part1)}

Parsing the input takes the first line as the start time and the second containing all the bus numbers. We store the position of each numbered bus in the input along with its bus number in a tuple.

```elm {l}
parse : List String -> ( Int, List ( Int, Int ) )
parse input =
    let
        indexedBusses =
            String.split ","
                >> List.indexedMap Tuple.pair
                >> List.map (\( i, s ) -> ( i, String.toInt s ))
                >> List.filter (\( i, ms ) -> ms /= Nothing)
                >> List.map (\( i, s ) -> ( i, s |> Maybe.withDefault 0 ))
    in
    case input of
        [ start, busses ] ->
            ( AOC.toInt start, indexedBusses busses )

        _ ->
            ( 0, [] ) |> Debug.log "bad input"
```

At any given time $t$, we can identify the busses that arrive:

```elm {l}
bussesAt : Int -> List Int -> List Int
bussesAt t =
    List.filter (\bus -> modBy bus t == 0)
```

We keep incrementing time after a given start time until we find a bus has arrived, at which point we find out how long after the start time it arrived and multiply that by its number.

```elm {l}
firstBusTime : Int -> Int -> List Int -> Int
firstBusTime start t busses =
    let
        arrived =
            bussesAt t busses
    in
    case arrived of
        [] ->
            firstBusTime start (t + 1) busses

        bus :: tl ->
            (t - start) * bus
```

```elm {l r}
part1 : Int
part1 =
    let
        ( start, busses ) =
            parse puzzleInput
                |> Tuple.mapSecond (List.map Tuple.second)
    in
    firstBusTime start start busses
```

---

{(part2|}

What is the earliest timestamp such that all of the listed bus IDs depart at offsets matching their positions in the list?

{|part2)}

It is a useful observation to note that all bus numbers in the input and examples are prime.

At any given time $t$ we can find out how many minutes each of the next busses will take to arrive at their preferred time (i.e. 1 minute after the previous one). Because we are not concerned with intermediate unnamed busses we use the index position of the numbered busses to find out how many minutes after the first one each should arrive.

```elm {l}
timeToSequence : Int -> List ( Int, Int ) -> List Int
timeToSequence t =
    List.map (\( i, id ) -> modBy id (t + i))
```

The task becomes finding the value of $t$ such at `timeToSequence` is a list of zeros (i.e. each bus arrives exactly at its slot and no later).

When the first bus arrives (which will always be at $t=0$) we know that the target time must be a multiple of its bus ID0 (it arrives every ID0 minutes), so we can increment $t$ by at least ID0 minutes when searching.

The next bus to arrive at its allocated slot will be when the second value in `timeToSequence` is zero. Because all the bus numbers are prime, at that point we know that we can now increment $t$ by at least ID0\*ID1 minutes.

This gives us a general pattern, which is to find the busses that correspond to the leading zeros in `timeToSequence`, find their product and increment $t$ by that value until all all busses have been found.

```elm {l}
tStep : List ( Int, Int ) -> List Int -> Int
tStep iBusses deps =
    let
        numConsecutiveArrivals =
            AOC.takeWhile ((==) 0) deps |> List.length
    in
    if numConsecutiveArrivals == 0 then
        1

    else
        List.map Tuple.second iBusses
            |> List.take numConsecutiveArrivals
            |> List.product
```

```elm {l}
solve : Int -> List ( Int, Int ) -> Int
solve t iBusses =
    let
        remainders =
            timeToSequence t iBusses
    in
    if List.all ((==) 0) remainders then
        t

    else
        solve (t + tStep iBusses remainders) iBusses
```

```elm {l r}
part2 : Int
part2 =
    puzzleInput
        |> parse
        |> Tuple.second
        |> List.sortBy (Tuple.second >> (*) -1)
        |> solve 0
```

---

## Reflection

I enjoyed trying to find the solution for part 2. I did the following:

- First attempt was to start with a large initial value of $t$ and then increment it in steps of the first bus's ID. This didn't yield an answer in a short time so I looked for ways of increasing the time step.

- I then looked at the list of values generated by `timeToSequence` for consecutive values of $t$. For the test input given in the question `[17,x,13,19]` the first zero in that list occurred every 17 steps. Incrementing $t$ by 17 instead generated a result with two leading zeros every 13 steps (now 17 minutes per step). Incrementing instead by 17\*13 steps yielded three leading zeros (and the answer). This suggested the general approach I adopted.

- I added a minor efficiency improvement by pre-sorting the busses from largest to smallest number so to increase the t-step as rapidly as possible. But given the solution is found quickly anyway, this doesn't make a great deal of difference with my input.

- My solution is dependent on the set of bus numbers being pairwise co-prime (e.g [4,15] or [121,122,123]). Without that property there could be cycles that repeat never having included a t+1 sequence. Puzzle inputs seem to comprise prime numbers only so this more than satisfies that condition.

### Chinese Remainder Theorem

I read subsequently that this could also be solved with the [Chinese Remainder Theorem](https://en.wikipedia.org/wiki/Chinese_remainder_theorem). While I was aware there was a theorem of that name and it had something to do with modulo arithmetic, I was not sufficiently familiar with it to have have been able to spot its application here. Mostly for my benefit, this is my understanding of the theorem:

Suppose we are trying to find a number $x$ and all we know is that when $x$ is divided by 11 it has a remainder of 10. There are an infinite number of values of $x$ that could satisfy this condition, for example 10, 21, 32, 43, 54, 65, 76, 87... etc. all generate a remainder of 10 when divided by 11.

But suppose we also knew that when $x$ is divided by 12 its remainder is 4. The infinite sequence of possible $x$ values for this condition alone would be 4, 16, 28, 40, 52, 64, 76, 88...

The lowest value of $x$ that satisfies both conditions is **76** (present in both sequences), the next lowest is **208**.

If we added a third constraint that when $x$ divided by 13 it has a remainder of 12 (giving candidates 12, 25, 38, 51...etc.), the lowest value of $x$ that satisfies all three constraints is **1000**

The Chinese remainder theorem allows us to find the first case that satisfies a series of remainder-modulus pair constraints such that product of all the moduli (11, 12 and 13 == 1716 this example) is the length of each cycle of $x$ that satisfies all the remainder-modulus constraints. In other words, the first value that satisfies all three in this example is 1000, the second is 1000 + (11\*12\*13) = 2716, the third is 1000 + 2\*1716 etc.

However, there are some moduli that would not allow us to find this value. And in particular if any of the pairs of moduli in the set of constraints are not _co-prime_, that is they can both be divided by a number larger than 1, there will be no solution. For example (0,10) and (1,5) has no solution, but (0,10) and (1,7) does (a sequence 50, 120, 190...)

The similarities with the bus puzzle are now more apparent to me as the modulus is just the bus number and the remainder is the position of each bus in the sequence relative to the start point (0 for the first bus, -1 for the second bus, -2 for the third etc.).

In Elm this can easily be calculated with [Arithmetic.chineseRemainder](https://package.elm-lang.org/packages/lynn/elm-arithmetic/latest/Arithmetic#chineseRemainder), so for the examples given in the puzzle description:

17,x,13,19: ^^^elm r=(Arithmetic.chineseRemainder [(0,17),(-2,13),(-3,19)])^^^
67,7,59,61: ^^^elm r=(Arithmetic.chineseRemainder [(0,67),(-1,7),(-2,59),(-3,61)])^^^
67,x,7,59,61: ^^^elm r=(Arithmetic.chineseRemainder [(0,67),(-2,7),(-3,59),(-4,61)])^^^
67,7,x,59,61: ^^^elm r=(Arithmetic.chineseRemainder [(0,67),(-1,7),(-3,59),(-4,61)])^^^
1789,37,47,1889: ^^^elm r=(Arithmetic.chineseRemainder [(0,1789),(-1,37),(-2,47),(-3,1889)])^^^
