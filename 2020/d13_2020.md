---
follows: data/d13_2020.md

id: "litvis"
---

@import "../css/aoc.less"

# Day 13 (2020): Shuttle Search

'Part One' and 'Part Two' puzzle descriptions and puzzle input from [Advent of Code](https://adventofcode.com/2020/day/13).

{(part1 |}

What is the ID of the earliest bus you can take to the airport multiplied by the number of minutes you'll need to wait for that bus?

{|part1)}

Parsing the input takes the first line as the start time and the second containing all the bus numbers. We store the position of each numbered bus in the input along with its bus number in a tuple.

```elm {l}
parse : List String -> ( Int, List ( Int, Int ) )
parse input =
    let
        indexedBusses =
            String.split ","
                >> List.indexedMap Tuple.pair
                >> List.map (\( i, s ) -> ( i, String.toInt s ))
                >> List.filter (\( i, ms ) -> ms /= Nothing)
                >> List.map (\( i, s ) -> ( i, s |> Maybe.withDefault 0 ))
    in
    case input of
        [ start, busses ] ->
            ( AOC.toInt start, indexedBusses busses )

        _ ->
            ( 0, [] ) |> Debug.log "bad input"
```

At any given time $t$, we can identify the busses that arrive:

```elm {l}
bussesAt : Int -> List Int -> List Int
bussesAt t =
    List.filter (\bus -> modBy bus t == 0)
```

We keep incrementing time after a given start time until we find a bus has arrived, at which point we find out how long after the start time it arrived and multiply that by its number.

```elm {l}
firstBusTime : Int -> Int -> List Int -> Int
firstBusTime start t busses =
    let
        arrived =
            bussesAt t busses
    in
    case arrived of
        [] ->
            firstBusTime start (t + 1) busses

        bus :: tl ->
            (t - start) * bus
```

```elm {l r}
part1 : Int
part1 =
    let
        ( start, busses ) =
            parse puzzleInput
                |> Tuple.mapSecond (List.map Tuple.second)
    in
    firstBusTime start start busses
```

---

{(part2|}

What is the earliest timestamp such that all of the listed bus IDs depart at offsets matching their positions in the list?

{|part2)}

At any given time $t$ we can find out how many minutes each of the next busses will take to arrive at their preferred time (i.e. 1 minute after the previous one). Because we are not concerned with intermediate unnamed busses we use the index position of the numbered busses to find out how many minutes after the first one each should arrive.

```elm {l}
timeToSequence : Int -> List ( Int, Int ) -> List Int
timeToSequence t =
    List.map (\( i, id ) -> modBy id (t + i))
```

The task becomes finding the value of $t$ such at `timeToSequence` is a list of zeros (i.e. each bus arrives exactly at its slot and no later).

When the first bus arrives (which will always be at $t=0$) we know that the target time must be a multiple of its bus ID0 (it arrives every ID0 minutes), so we can increment $t$ by at least ID0 minutes when searching.

The next bus to arrive at its allocated slot will be when the second value in `timeToSequence` is zero. At that point we know that we can now increment $t$ by at least ID0\*ID1 minutes.

This gives us a general pattern, which is to find the busses that correspond to the leading zeros in `timeToSequence`, find their product and increment $t$ by that value until all all busses have been found.

```elm {l}
tStep : List ( Int, Int ) -> List Int -> Int
tStep iBusses deps =
    let
        numConsecutiveArrivals =
            AOC.takeWhile ((==) 0) deps |> List.length
    in
    if numConsecutiveArrivals == 0 then
        1

    else
        List.map Tuple.second iBusses
            |> List.take numConsecutiveArrivals
            |> List.product
```

```elm {l}
solve : Int -> List ( Int, Int ) -> Int
solve t iBusses =
    let
        remainders =
            timeToSequence t iBusses
    in
    if List.all ((==) 0) remainders then
        t

    else
        solve (t + tStep iBusses remainders) iBusses
```

```elm {l r}
part2 : Int
part2 =
    puzzleInput
        |> parse
        |> Tuple.second
        |> solve 0
```

---

## Reflection

I enjoyed trying to find the solution for part 2. I did the following:

- First attempt was to start with a large initial value of $t$ and then increment it in steps of the first bus's ID. This didn't yield an answer in a short time so I looked for ways of increasing the time step.

- I then looked at the list of values generated by `timeToSequence` for consecutive values of $t$. For the test input given in the question `[17,x,13,19]` the first zero in that list occurred every 17 steps. Incrementing $t$ by 17 instead generated a result with two leading zeros every 13 steps (now 17 minutes per step). Incrementing instead by 17\*13 steps yielded three leading zeros (and the answer). This suggested the general approach I adopted.

I read subsequently that this could also be solved with the [Chinese Remainder Theorem](https://en.wikipedia.org/wiki/Chinese_remainder_theorem). While I was aware there was a theorem of that name and it had something to do with modulo arithmetic, I would not have been spot its application here.
