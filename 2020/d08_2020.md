---
follows: data/d08_2020.md

id: "litvis"
---

@import "../css/aoc.less"

# Day 8 (2020): Handheld Halting

'Part One' and 'Part Two' puzzle descriptions and puzzle input from [Advent of Code](https://adventofcode.com/2020/day/8)

{(part1|}

Run your copy of the boot code. Immediately before any instruction is executed a second time, what value is in the accumulator?

{|part1)}

Firstly we need to be able to represent the state of the console, including the accumulator, the memory position of the current instruction, the set of boot code instructions and the status of the console. In order to detect repeated instructions, we also store a history of previously accessed memory addresses.

```elm {l}
type alias Console =
    { acc : Int
    , pos : Int
    , instructions : Deque Instruction
    , history : Set Int
    , status : Status
    }
```

The instruction set itself is a simple:

```elm {l}
type Instruction
    = ACC Int
    | JMP Int
    | NOP Int
```

The console can be in one of three states: it may be running a program normally, it may have entered an infinite loop or it may have completed.

```elm {l}
type Status
    = Running Int
    | Infinite Int
    | Halt Int
```

Parsing the input instructions is straightforward:

```elm {l}
parse : List String -> Deque Instruction
parse =
    let
        toVal s =
            if String.startsWith "+" s then
                AOC.toInt (String.dropLeft 1 s)

            else
                AOC.toInt s

        toOp s =
            case String.split " " s of
                [ op, val ] ->
                    case op of
                        "acc" ->
                            ACC (toVal val)

                        "jmp" ->
                            JMP (toVal val)

                        "nop" ->
                            NOP (toVal val)

                        _ ->
                            NOP 0 |> Debug.log "unknown instruction"

                _ ->
                    NOP 0 |> Debug.log "bad input"
    in
    List.map toOp >> Deque.fromList
```

Running the program just involves issuing instructions and updating the accumulator and current memory address as appropriate. We can stop execution either if we process a memory address for a second time, or the current memory address is outside the instruction set.

```elm {l}
run : Console -> Console
run console =
    if Set.member console.pos console.history then
        { console | status = Infinite console.acc }

    else if console.pos >= Deque.length console.instructions then
        { console | status = Halt console.acc }

    else
        case Deque.first console.instructions |> Maybe.withDefault (NOP 0) of
            ACC n ->
                run
                    { console
                        | acc = console.acc + n
                        , history = Set.insert console.pos console.history
                        , pos = console.pos + 1
                        , instructions = AOC.rotateDeque 1 console.instructions
                    }

            JMP n ->
                run
                    { console
                        | history = Set.insert console.pos console.history
                        , pos = console.pos + n
                        , instructions = AOC.rotateDeque n console.instructions
                    }

            NOP n ->
                run
                    { console
                        | history = Set.insert console.pos console.history
                        , pos = console.pos + 1
                        , instructions = AOC.rotateDeque 1 console.instructions
                    }
```

```elm {l r}
part1 : Status
part1 =
    { acc = 0, pos = 0, history = Set.empty, instructions = parse puzzleInput, status = Running 0 }
        |> run
        |> .status
```

---

{(part2|}

Fix the program so that it terminates normally by changing exactly one jmp (to nop) or nop (to jmp). What is the value of the accumulator after the program terminates?

{|part2)}

In order to change specific instructions in the program it is useful to create convenience functions for examining and changing individual instructions (since Elm does not use random access arrays).

```elm {l}
peek : Int -> Console -> Instruction
peek addr console =
    AOC.rotateDeque addr console.instructions
        |> Deque.first
        |> Maybe.withDefault (NOP 0)


poke : Int -> Instruction -> Console -> Console
poke addr instr console =
    let
        newInstr =
            AOC.rotateDeque addr console.instructions
                |> Deque.popFront
                |> Tuple.second
                |> Deque.pushFront instr
                |> AOC.rotateDeque -addr
    in
    { console | instructions = newInstr }
```

We can tentatively toggle NOP/JMP instructions at a given address, but there is no need to toggle a NOP 0 since JMP 0 will always create an infinite loop.

```elm {l}
toggle : Int -> Console -> Console
toggle addr console =
    case peek addr console of
        NOP n ->
            if n /= 0 then
                poke addr (JMP n) console

            else
                console

        JMP n ->
            poke addr (NOP n) console

        _ ->
            console
```

To find which instruction can toggle the program to allow a normal halting state we try toggling each address in turn until running the program exits normally.

```elm {l}
test : Int -> Console -> Status
test addr console =
    if addr >= Deque.length console.instructions then
        Infinite -1

    else
        case run (toggle addr console) |> .status of
            Halt n ->
                Halt n

            _ ->
                test (addr + 1) console
```

```elm {l r}
part2 : Status
part2 =
    { acc = 0, pos = 0, history = Set.empty, instructions = parse puzzleInput, status = Running 0 }
        |> test 0
```

---

## Reflection

As has become a tradition, at least one puzzle with some form of low-level virtual machine. In this case the instruction set is very simple, so my solution may be a little over engineered. Looking at part 1, I had anticipated the possibility of circular memory address jumping, given that infinite looping was being considered. However, this turned out not to be the case.

Part two is not particularly efficient in that the program is run n times (where n is the number of instructions in the program). It could be made more efficient by taking the history from the first (untoggled) run, filtering out only those with NOP (n /= 1) and JMP instructions and testing runs with just those values toggled. However, it runs fast enough for the puzzle input, so I didn't implement this.
