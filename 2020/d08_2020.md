---
follows: data/d08_2020.md

id: "litvis"
---

@import "../css/aoc.less"

# Day 8 (2020): Handheld Halting

'Part One' and 'Part Two' puzzle descriptions and puzzle input from [Advent of Code](https://adventofcode.com/2020/day/8)

{(part1|}

Run your copy of the boot code. Immediately before any instruction is executed a second time, what value is in the accumulator?

{|part1)}

Firstly we need to be able to represent the state of the console, including the accumulator, the memory position of the current instruction, the set of boot code instructions and the status of the console. In order to detect repeated instructions, we also store a history of previously accessed memory addresses.

```elm {l}
type alias Console =
    { acc : Int
    , pos : Int
    , instructions : Deque Instruction
    , history : Set Int
    , status : Status
    }
```

The instruction set itself is a simple:

```elm {l}
type Instruction
    = ACC Int
    | JMP Int
    | NOP Int
```

The console can be in one of three states: it may be running a program normally, it may have entered an infinite loop or it may have completed.

```elm {l}
type Status
    = Running Int
    | Infinite Int
    | Halt Int
```

Parsing the input instructions is straightforward:

```elm {l}
parse : List String -> Deque Instruction
parse =
    let
        toVal s =
            if String.startsWith "+" s then
                AOC.toInt (String.dropLeft 1 s)

            else
                AOC.toInt s

        toOp s =
            case String.split " " s of
                [ op, val ] ->
                    case op of
                        "acc" ->
                            ACC (toVal val)

                        "jmp" ->
                            JMP (toVal val)

                        "nop" ->
                            NOP (toVal val)

                        _ ->
                            NOP 0 |> Debug.log "unknown instruction"

                _ ->
                    NOP 0 |> Debug.log "bad input"
    in
    List.map toOp >> Deque.fromList
```

Running the program just involves issuing instructions and updating the accumulator and current memory address as appropriate. We can stop execution either if we process a memory address for a second time, or the current memory address is outside the instruction set.

```elm {l}
run : Console -> Console
run console =
    if Set.member console.pos console.history then
        { console | status = Infinite console.acc }

    else if console.pos >= Deque.length console.instructions then
        { console | status = Halt console.acc }

    else
        case Deque.first console.instructions |> Maybe.withDefault (NOP 0) of
            ACC n ->
                run
                    { console
                        | acc = console.acc + n
                        , history = Set.insert console.pos console.history
                        , pos = console.pos + 1
                        , instructions = AOC.rotateDeque 1 console.instructions
                    }

            JMP n ->
                run
                    { console
                        | history = Set.insert console.pos console.history
                        , pos = console.pos + n
                        , instructions = AOC.rotateDeque n console.instructions
                    }

            NOP n ->
                run
                    { console
                        | history = Set.insert console.pos console.history
                        , pos = console.pos + 1
                        , instructions = AOC.rotateDeque 1 console.instructions
                    }
```

```elm {l r}
part1 : Status
part1 =
    { acc = 0, pos = 0, history = Set.empty, instructions = parse puzzleInput, status = Running 0 }
        |> run
        |> .status
```

{(part2|}

Fix the program so that it terminates normally by changing exactly one jmp (to nop) or nop (to jmp). What is the value of the accumulator after the program terminates?

{|part2)}

Because Elm does not use random access arrays, it is useful to create convenience functions for examining and changing individual instructions.

```elm {l}
peek : Console -> Int -> Instruction
peek console addr =
    AOC.rotateDeque addr console.instructions
        |> Deque.first
        |> Maybe.withDefault (NOP 0)


poke : Console -> Int -> Instruction -> Console
poke console addr instr =
    let
        newInstr =
            AOC.rotateDeque addr console.instructions
                |> Deque.popFront
                |> Tuple.second
                |> Deque.pushFront instr
                |> AOC.rotateDeque -addr
    in
    { console | instructions = newInstr }


toggle : Int -> Console -> Console
toggle addr console =
    case peek console addr of
        NOP n ->
            poke console addr (JMP n)

        JMP n ->
            poke console addr (NOP n)

        _ ->
            console


historyAddrs : Console -> List ( Int, Instruction )
historyAddrs console =
    console.history |> Set.toList |> List.map (\addr -> ( addr, peek console addr ))
```

We can determine if we should toggle a given instruction by checking it is either NOP or JMP. There is no point in toggling NOP 0 since that guarantees an infinite loop.

```elm {l}
canToggle : Instruction -> Bool
canToggle instr =
    case instr of
        JMP _ ->
            True

        NOP n ->
            n /= 0

        _ ->
            False
```

We will need to determine whether or not a running program halts:

```elm {l}
isHalt : Status -> Bool
isHalt status =
    case status of
        Halt _ ->
            True

        _ ->
            False
```

Finally we bring things together by finding all the togglable instructions after running the program once, then running the program once for each of them after toggling, looking for ones that halt correctly.

```elm {l r}
part2 : List Status
part2 =
    let
        console =
            { acc = 0, pos = 0, history = Set.empty, instructions = parse puzzleInput, status = Running 0 }
    in
    run console
        |> historyAddrs
        |> List.filter (Tuple.second >> canToggle)
        |> List.map (\( addr, _ ) -> run (toggle addr console) |> .status)
        |> List.filter isHalt
```

---

## Reflection

As has become a tradition, at least one puzzle with some form of low-level virtual machine. In this case the instruction set is very simple, so my solution may be a little over engineered. Looking at part 1, I had anticipated the possibility of circular memory address jumping, given that infinite looping was being considered. However, this turned out not to be the case.

For part 2, my first attempt simply ran the program _n_ times, where _n_ is the number of instructions in the program, after attempting to toggle each instruction. This found the solution quickly enough but was not particularly efficient. Refining so that only only running programs containing visited and togglable instructions provided a more efficient approach. It reduced the number of times the program was run from 638 to 91.

It seems a characteristic of the earlier puzzles that brute force approaches still work, inviting, but not requiring, a more efficient process. I like this level of puzzle difficulty in that it can appeal to a wider range of program sophistication levels without punishing simpler approaches too heavily.
