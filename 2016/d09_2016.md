---
follows: data/d09_2016.md

id: "litvis"
---

@import "../css/aoc.less"

# Day 9 (2016): Explosives in Cyberspace

'Part One' and 'Part Two' puzzle descriptions and puzzle input from [Advent of Code](https://adventofcode.com/2016/day/9).

{( part1|}

What is the **decompressed length** of the file (your puzzle input)? Don't count whitespace.

{| part1 )}

The question asks only for the length of the decompressed sequence not the actual characters. So is it possible to calculate the length without decompressing?

Consider some simple cases:

`ADVENT` decompresses to `ADVENT` with a length of **6**
`(6x1)ADVENT` decompresses to ADVENT with a length of **6**
`(6x2)ADVENT` decompresses to ADVENTADVENT with a length of **12**
`(6x3)ADVENT` decompresses to ADVENTADVENTADVENT with a length of **18**
`(3x1)ADVENT` decompresses to ADVENT with a length of **6**
`(3x2)ADVENT` decompresses to ADVADVENT with a length of **9**
`(3x3)ADVENT` decompresses to ADVADVADVENT with a length of **12**

So given a string `(nxr)someText`, we can express the total length as

_n\*(r-1) + length(`someText`)_

We need to be able to extract the first _n_ and _r_ values from the input text:

```elm {l}
markerParams : String -> List String
markerParams =
    AOC.submatches "^\\((\\d+)x(\\d+)\\)" >> List.filterMap identity
```

We can apply the length rule sequentially along the entire string, accumulating the length character at a time and skipping _markerLength_ characters every time we find a marker. We can marginally speed things up by additionally skipping _n_ characters after a marker and modifying the length rule to be _n\*r_ to account for those skipped characters:

```elm {l}
ucLength : Int -> String -> Int
ucLength totalLen todo =
    if todo == "" then
        totalLen

    else
        case markerParams todo of
            [ n, r ] ->
                -- Text generated by marker
                let
                    markerLength =
                        String.length (n ++ r) + 3
                in
                ucLength (totalLen + AOC.toInt n * AOC.toInt r)
                    (String.dropLeft (markerLength + AOC.toInt n) todo)

            _ ->
                -- Text not generated by marker
                ucLength (totalLen + 1) (String.dropLeft 1 todo)
```

```elm {l r}
part1 : Int
part1 =
    puzzleInput |> ucLength 0
```

{( part2 |}

What is the decompressed length of the file using this improved format?

{| part2 )}

We can adapt the previous approach but this time we recursively add the length generated by the repeated markers:

```elm {l}
ucLength2 : Int -> String -> Int
ucLength2 totalLen todo =
    if todo == "" then
        totalLen

    else
        case markerParams todo of
            [ n, r ] ->
                -- Text generated by marker
                let
                    markerLength =
                        String.length (n ++ r) + 3

                    repSequence =
                        String.slice markerLength (markerLength + AOC.toInt n) todo
                in
                ucLength2 (totalLen + ucLength2 0 repSequence * AOC.toInt r)
                    (String.dropLeft (markerLength + AOC.toInt n) todo)

            _ ->
                -- Text not generated by marker
                ucLength2 (totalLen + 1) (String.dropLeft 1 todo)
```

```elm {l r}
part2 : Int
part2 =
    puzzleInput |> ucLength2 0
```

---

## Reflection

What I like about this puzzle the playfulness of the question that, via part 1, encourages an unnecessary full decompression of the input text distracting the puzzler from considering a simpler approach. Like a cryptic crossword setter, the elegance of the puzzle is in both hiding the simple solution, and hiding the fact that it is hidden.

Discussion on [r/adventofcode](https://www.reddit.com/r/adventofcode/comments/5hbygy/2016_day_9_solutions/) suggest a more efficient O(n) solution to Part 2 that doesn't involve recursing nested decompression.

_Give each character in the input a weight. Then for each non-marker character, as the input is read, increase its weight according to the decompression markers:_

- Initialise all characters weights to 1
- Scan input one character at a time and
- if it's a normal character, count its weight towards the total length
- if it's the beginning of a marker, read the marker and multiply character weights covered by the repetition by the values of the marker.

```elm {l}
ucLength3 : Int -> String -> Int
ucLength3 totalLen todo =
    if todo == "" then
        totalLen

    else
        case markerParams todo of
            [ n, r ] ->
                -- Text generated by marker
                let
                    markerLength =
                        String.length (n ++ r) + 3

                    repSequence =
                        String.slice markerLength (markerLength + AOC.toInt n) todo
                in
                ucLength2 (totalLen + ucLength3 0 repSequence * AOC.toInt r)
                    (String.dropLeft (markerLength + AOC.toInt n) todo)

            _ ->
                -- Text not generated by marker
                ucLength3 (totalLen + 1) (String.dropLeft 1 todo)
```

```elm {l r}
part2b : Int
part2b =
    puzzleInput |> ucLength3 0
```
