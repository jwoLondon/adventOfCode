---
follows: data/d09_2016.md

id: "litvis"
---

@import "../css/aoc.less"

# Day 9 (2016): Explosives in Cyberspace

'Part One' and 'Part Two' puzzle descriptions and puzzle input from [Advent of Code](https://adventofcode.com/2016/day/9):

{( part1|}

Wandering around a secure area, you come across a datalink port to a new part of the network.
After briefly scanning it for interesting files, you find one file in particular that catches your attention.
It's compressed with an experimental format, but fortunately, the documentation for the format is nearby.

The format compresses a sequence of characters.
Whitespace is ignored.
To indicate that some sequence should be repeated, a marker is added to the file, like (10x2).
To decompress this marker, take the subsequent 10 characters and repeat them 2 times.
Then, continue reading the file after the repeated data.
The marker itself is not included in the decompressed output.

If parentheses or other characters appear within the data referenced by a marker, that's okay - treat it like normal data, not a marker, and then resume looking for markers after the decompressed section.

For example:

- ADVENT contains no markers and decompresses to itself with no changes, resulting in a decompressed length of 6.

- A(1x5)BC repeats only the B a total of 5 times, becoming ABBBBBC for a decompressed length of 7.

- (3x3)XYZ becomes XYZXYZXYZ for a decompressed length of 9.

- A(2x2)BCD(2x2)EFG doubles the BC and EF, becoming ABCBCDEFEFG for a decompressed length of 11.

- (6x1)(1x3)A simply becomes (1x3)A - the (1x3) looks like a marker, but because it's within a data section of another marker, it is not treated any differently from the A that comes after it. It has a decompressed length of 6.

- X(8x2)(3x3)ABCY becomes X(3x3)ABC(3x3)ABCY (for a decompressed length of 18), because the decompressed data from the (8x2) marker (the (3x3)ABC) is skipped and not processed further.

What is the **decompressed length** of the file (your puzzle input)?
Don't count whitespace.

{| part1 )}

## Approach

The question asks only for the length of the decompressed sequence not the actual characters. So is it possible to calculate the length without decompressing?

Consider some simple cases:

`ADVENT` decompresses to `ADVENT` with a length of **6**
`(6x1)ADVENT` decompresses to ADVENT with a length of **6**
`(6x2)ADVENT` decompresses to ADVENTADVENT with a length of **12**
`(6x3)ADVENT` decompresses to ADVENTADVENTADVENT with a length of **18**
`(3x1)ADVENT` decompresses to ADVENT with a length of **6**
`(3x2)ADVENT` decompresses to ADVADVENT with a length of **9**
`(3x3)ADVENT` decompresses to ADVADVADVENT with a length of **12**

So given a string `(nxr)someText`, we can express the total length as

_n\*(r-1) + length(`someText`)_

## Parsing and accumulating

We need to be able to extract the first _n_ and _r_ values from the input text:

```elm {l}
markerParams : String -> List String
markerParams =
    submatches "^\\((\\d+)x(\\d+)\\)" >> List.filterMap identity
```

We can apply the length rule sequentially along the entire string, accumulating the length character at a time and skipping _markerLength_ characters every time we find a marker. We can marginally speed things up by additionally skipping _n_ characters after a marker and modifying the length rule to be _n\*r_ to account for those skipped characters:

```elm {l}
ucLength : Int -> String -> Int
ucLength totalLen todo =
    if todo == "" then
        totalLen

    else
        case markerParams todo of
            [ n, r ] ->
                -- Text generated by marker
                let
                    markerLength =
                        String.length (n ++ r) + 3
                in
                ucLength (totalLen + toInt n * toInt r)
                    (String.dropLeft (markerLength + toInt n) todo)

            _ ->
                -- Text not generated by marker
                ucLength (totalLen + 1) (String.dropLeft 1 todo)
```

```elm {l r}
part1 : Int
part1 =
    puzzleInput |> ucLength 0
```

{( part2 |}

Apparently, the file actually uses version two of the format.

In version two, the only difference is that markers within decompressed data are decompressed.
This, the documentation explains, provides much more substantial compression capabilities, allowing many-gigabyte files to be stored in only a few kilobytes.

For example:

- (3x3)XYZ still becomes XYZXYZXYZ, as the decompressed section contains no markers.

- X(8x2)(3x3)ABCY becomes XABCABCABCABCABCABCY, because the decompressed data from the (8x2) marker is then further decompressed, thus triggering the (3x3) marker twice for a total of six ABC sequences.

- (27x12)(20x12)(13x14)(7x10)(1x12)A decompresses into a string of A repeated 241920 times.

- (25x3)(3x3)ABC(2x3)XY(5x2)PQRSTX(18x9)(3x2)TWO(5x7)SEVEN becomes 445 characters long.

Unfortunately, the computer you brought probably doesn't have enough memory to actually decompress the file; you'll have to come up with another way to get its decompressed length.

What is the decompressed length of the file using this improved format?

{| part2 )}

We can adapt the previous approach but this time we recursively add the length generated by the repeated markers:

```elm {l}
ucLength2 : Int -> String -> Int
ucLength2 totalLen todo =
    if todo == "" then
        totalLen

    else
        case markerParams todo of
            [ n, r ] ->
                -- Text generated by marker
                let
                    markerLength =
                        String.length (n ++ r) + 3

                    repSequence =
                        String.slice markerLength (markerLength + toInt n) todo
                in
                ucLength2 (totalLen + ucLength2 0 repSequence * toInt r)
                    (String.dropLeft (markerLength + toInt n) todo)

            _ ->
                -- Text not generated by marker
                ucLength2 (totalLen + 1) (String.dropLeft 1 todo)
```

```elm {l r}
part2 : Int
part2 =
    puzzleInput |> ucLength2 0
```

## Reflection

What I like about this puzzle the playfulness of the question that, via part 1, encourages an unnecessary full decompression of the input text distracting the puzzler from considering a simpler approach. Like a cryptic crossword setter, the elegance of the puzzle is in both hiding the simple solution, and hiding the fact that it is hidden.

Discussion on [r/adventofcode](https://www.reddit.com/r/adventofcode/comments/5hbygy/2016_day_9_solutions/) suggest a more efficient O(n) solution to Part 2 that doesn't involve recursing nested decompression.

_Give each character in the input a weight. Then for each non-marker character, as the input is read, increase its weight according to the decompression markers:_

- Initialise all characters weights to 1
- Scan input one character at a time and
- if it's a normal character, count its weight towards the total length
- if it's the beginning of a marker, read the marker and multiply character weights covered by the repetition by the values of the marker.

```elm {l}
ucLength3 : Int -> String -> Int
ucLength3 totalLen todo =
    if todo == "" then
        totalLen

    else
        case markerParams todo of
            [ n, r ] ->
                -- Text generated by marker
                let
                    markerLength =
                        String.length (n ++ r) + 3

                    repSequence =
                        String.slice markerLength (markerLength + toInt n) todo
                in
                ucLength2 (totalLen + ucLength3 0 repSequence * toInt r)
                    (String.dropLeft (markerLength + toInt n) todo)

            _ ->
                -- Text not generated by marker
                ucLength3 (totalLen + 1) (String.dropLeft 1 todo)
```

```elm {l r}
part2b : Int
part2b =
    "X(8x2)(3x3)ABCY" |> ucLength3 0
```
